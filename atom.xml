<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XBlame</title>
  
  <subtitle>XBlame&#39;s Personal Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://note.xblame.top/"/>
  <updated>2019-08-10T14:26:44.633Z</updated>
  <id>http://note.xblame.top/</id>
  
  <author>
    <name>XBlame</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>After实习一个月</title>
    <link href="http://note.xblame.top/2019/08/10/After%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%9C%88/"/>
    <id>http://note.xblame.top/2019/08/10/After实习一个月/</id>
    <published>2019-08-10T12:05:32.000Z</published>
    <updated>2019-08-10T14:26:44.633Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这一年的七月初我走出校门，来到公司实习，到现在已经一个月了。感觉这一个月过的很快，变化很快，接触到的东西很多。可能就是因为太充实了，还没等我考虑时间，时间已经过去了，记录一下接触到的人和事，算是成长中的一份记忆备份。&lt;/p&gt;
&lt;p&gt;七月四日，我来到苏州华为研究所实习，以下简
        
      
    
    </summary>
    
      <category term="生活" scheme="http://note.xblame.top/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux下GNU开发ARM</title>
    <link href="http://note.xblame.top/2019/04/21/Linux%E4%B8%8BGNU%E5%BC%80%E5%8F%91ARM/"/>
    <id>http://note.xblame.top/2019/04/21/Linux下GNU开发ARM/</id>
    <published>2019-04-21T02:48:00.000Z</published>
    <updated>2019-04-21T04:10:48.628Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;该篇实现的平台是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Archlinux kernel:5.0.7-arch1-1-ARCH&lt;/li&gt;
&lt;li&gt;arm-none-eabi-gcc&lt;/li&gt;
&lt;li&gt;stm32CubeMx
        
      
    
    </summary>
    
      <category term="操作系统" scheme="http://note.xblame.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux,arm,gnu" scheme="http://note.xblame.top/tags/linux-arm-gnu/"/>
    
  </entry>
  
  <entry>
    <title>借助cortex-m3内核理解单核多线程实现细节</title>
    <link href="http://note.xblame.top/2019/04/11/%E5%80%9F%E5%8A%A9cortex-m3%E5%86%85%E6%A0%B8%E7%90%86%E8%A7%A3%E5%8D%95%E6%A0%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
    <id>http://note.xblame.top/2019/04/11/借助cortex-m3内核理解单核多线程实现细节/</id>
    <published>2019-04-11T06:51:37.000Z</published>
    <updated>2019-04-11T09:30:42.985Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
      <category term="操作系统" scheme="http://note.xblame.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="context,switch,cortex-m,多线程" scheme="http://note.xblame.top/tags/context-switch-cortex-m-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++析构函数-虚和非虚</title>
    <link href="http://note.xblame.top/2019/03/20/C-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E8%99%9A%E5%92%8C%E9%9D%9E%E8%99%9A/"/>
    <id>http://note.xblame.top/2019/03/20/C-析构函数-虚和非虚/</id>
    <published>2019-03-20T04:17:35.000Z</published>
    <updated>2019-03-20T13:53:05.243Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;C++的类析构函数通常都是虚函数。这是因为虚函数是动态绑定的。如果一个类有可能成为基类则其析构函数必须为虚函数，如果不可能成为基类，则无所谓。实验如下:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-cpp&quot;&gt;class A{
public:
    A(){
 
        
      
    
    </summary>
    
      <category term="C++" scheme="http://note.xblame.top/categories/C/"/>
    
    
      <category term="C++,析构函数,虚函数" scheme="http://note.xblame.top/tags/C-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++ new和malloc</title>
    <link href="http://note.xblame.top/2019/03/20/C-new%E5%92%8Cmalloc/"/>
    <id>http://note.xblame.top/2019/03/20/C-new和malloc/</id>
    <published>2019-03-20T02:09:56.000Z</published>
    <updated>2019-03-20T04:21:26.461Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;new 是 C++ 中的操作符，一般为类的实例变量分配内存，与之对应的内存释放函数是 delete,&lt;br&gt;malloc 是 C 语言的内存分配的函数，进行堆区已映射的内存的管理和采用系统调用增加内存映射区域。&lt;/p&gt;
&lt;h4 id=&quot;输入参数上的不同&quot;&gt;&lt;a
        
      
    
    </summary>
    
      <category term="C++" scheme="http://note.xblame.top/categories/C/"/>
    
    
      <category term="C++,new,malloc" scheme="http://note.xblame.top/tags/C-new-malloc/"/>
    
  </entry>
  
  <entry>
    <title>算法学习-寻找最大子数组和</title>
    <link href="http://note.xblame.top/2019/01/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <id>http://note.xblame.top/2019/01/30/最大连续子数组和/</id>
    <published>2019-01-30T09:31:52.210Z</published>
    <updated>2019-01-30T09:31:52.210Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;通过对算法导论的再次学习，重新温习了一些比较经典的算法问题。今天看的是寻找给定数组的最大连续子数组和，问题是这样的：在给出的一个数组中，找出相加和最大的连续子数组，例如在数组&lt;em&gt;A={-1,2,3,4,-3,1}&lt;/em&gt;中，最大连续子数组为&lt;em&gt;{2,3,4}&lt;/e
        
      
    
    </summary>
    
      <category term="代码" scheme="http://note.xblame.top/categories/%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="算法" scheme="http://note.xblame.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="http://note.xblame.top/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://note.xblame.top/2018/10/19/设计模式-观察者模式/</id>
    <published>2018-10-19T12:21:14.000Z</published>
    <updated>2019-01-30T03:38:11.006Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;设计模式理解到什么地步才叫理解呢，我阅历还浅，讲道理也是讲想象中的道理，难免中气不足。我觉得设计模式并不难，当一件事很复杂的时候，是很难看出到底是用哪种设计模式的，因为他可能什么模式都有，严格定义的话，又什么设计模式都不是,可能需要划分成很多小部分。就我而言，设计模式给了我
        
      
    
    </summary>
    
      <category term="设计模式" scheme="http://note.xblame.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式,观察者" scheme="http://note.xblame.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式</title>
    <link href="http://note.xblame.top/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://note.xblame.top/2018/10/19/设计模式-策略模式/</id>
    <published>2018-10-19T11:58:01.000Z</published>
    <updated>2019-01-30T03:45:52.770Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;策略模式是一种选择，给一个灵活的接口，然后去选择，只要是这个接口下的子类，我们都能去选，在不同的场合，选择会不同，这就是策略。客户端或者是决策者，是依赖于这个接口的，而不依赖具体的实现。&lt;/p&gt;
&lt;p&gt;如排序算法是有很多种的，所有排序算法都可以实现排序这个接口。&lt;/p&gt;
&lt;
        
      
    
    </summary>
    
      <category term="设计模式" scheme="http://note.xblame.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式,策略模式" scheme="http://note.xblame.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-桥接模式</title>
    <link href="http://note.xblame.top/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://note.xblame.top/2018/10/18/设计模式-桥接模式/</id>
    <published>2018-10-18T12:43:03.000Z</published>
    <updated>2019-01-30T03:45:13.670Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;桥接模式是虚拟了一座“桥”，只不过这座”桥”的两端是抽象和实体。在维基百科用的是抽象的图形和画图的关系，我尝试找一中新的例子来两相比较促进理解。&lt;/p&gt;
&lt;p&gt;鸟是会飞的，不同的鸟有不同的飞行姿态，当然有的不是鸟的也可以飞。所以建立一个飞行的接口&lt;/p&gt;
&lt;pre&gt;&lt;cod
        
      
    
    </summary>
    
      <category term="设计模式" scheme="http://note.xblame.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式,桥接模式" scheme="http://note.xblame.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-适配器模式</title>
    <link href="http://note.xblame.top/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://note.xblame.top/2018/10/18/设计模式-适配器模式/</id>
    <published>2018-10-18T11:04:21.000Z</published>
    <updated>2019-01-30T03:44:13.950Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;适配器并不是一个软件开发的专用术语，而是应用于生活的方方面面，一般用来提供不同接口之间的转接。例如下图：&lt;/p&gt;
&lt;p&gt;&lt;img
        
      
    
    </summary>
    
      <category term="设计模式" scheme="http://note.xblame.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式，适配器" scheme="http://note.xblame.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E9%80%82%E9%85%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-抽象工厂模式</title>
    <link href="http://note.xblame.top/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://note.xblame.top/2018/10/18/设计模式-抽象工厂模式/</id>
    <published>2018-10-18T08:00:18.000Z</published>
    <updated>2019-01-30T03:36:38.610Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;走过了简单工厂模式和工厂模式，我来了解一下抽象工厂模式，现在已经知道“工厂”二字的含义了，就是帮别人建造对象，想想JDBC(数据库连接库)中用到的getConnection之类的方法，这就是工厂模式的应用啊。但是简单工厂模式和工厂模式都存在那个添加和修改必须更改以前代码的问
        
      
    
    </summary>
    
      <category term="设计模式" scheme="http://note.xblame.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式,工厂模式" scheme="http://note.xblame.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://note.xblame.top/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://note.xblame.top/2018/10/18/设计模式-工厂模式/</id>
    <published>2018-10-18T03:33:39.000Z</published>
    <updated>2019-01-30T03:37:29.050Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;上一篇遗漏了一些问题，工厂模式特别适合那种创建比较复杂的对象，这样将创建的任务交给其他部分，使得客户端代码更简介，调用更方便。后来者少写代码，减少代码的重复，提高复用性。&lt;br&gt;简单工厂模式比工厂模式简单，但工厂模式是简单工厂模式的进化么？我觉得不是，因为该少的东西一点都没
        
      
    
    </summary>
    
      <category term="设计模式" scheme="http://note.xblame.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式,工厂模式" scheme="http://note.xblame.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-简单工厂模式</title>
    <link href="http://note.xblame.top/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://note.xblame.top/2018/10/18/设计模式-简单工厂模式/</id>
    <published>2018-10-18T02:11:16.000Z</published>
    <updated>2019-01-30T03:38:47.870Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;公认的有理之言已经被传递的铺天盖地，不多我一个传播者，所以我说一下自己的思考，还希望看到的人对有错存疑之言不吝赐教。&lt;/p&gt;
&lt;p&gt;设计模式是在实践中总结出的做出更好的软件的一些方法，什么是更好的软件，就我看来是在当前基础上不管是修改还是添加，都能给开发者省点力气的软件。能
        
      
    
    </summary>
    
      <category term="设计模式" scheme="http://note.xblame.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式,工厂模式" scheme="http://note.xblame.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Archlinux 安装.net core</title>
    <link href="http://note.xblame.top/2018/10/16/Archlinux-%E5%AE%89%E8%A3%85-net-core/"/>
    <id>http://note.xblame.top/2018/10/16/Archlinux-安装-net-core/</id>
    <published>2018-10-16T12:55:13.000Z</published>
    <updated>2018-10-16T13:22:29.176Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;从Arch源安装:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;sudo pacman -S dotnet-sdk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个时候已经安装了.net core&lt;br&gt;找一个心仪的存放工程的目录&lt;/p&gt;
&lt;pre&gt;&lt;code
        
      
    
    </summary>
    
      <category term="疑难杂症" scheme="http://note.xblame.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="Archlinux,dotnet core" scheme="http://note.xblame.top/tags/Archlinux-dotnet-core/"/>
    
  </entry>
  
  <entry>
    <title>Archlinux安装Boost库</title>
    <link href="http://note.xblame.top/2018/10/16/Archlinux%E5%AE%89%E8%A3%85Boost/"/>
    <id>http://note.xblame.top/2018/10/16/Archlinux安装Boost/</id>
    <published>2018-10-16T12:41:38.000Z</published>
    <updated>2018-10-16T12:53:41.069Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Archlinux 软件源中有boost 不需要自己编译安装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;lang-bash&quot;&gt;sudo pacman -S
        
      
    
    </summary>
    
      <category term="Boost" scheme="http://note.xblame.top/categories/Boost/"/>
    
    
      <category term="boost,Archlinux" scheme="http://note.xblame.top/tags/boost-Archlinux/"/>
    
  </entry>
  
  <entry>
    <title>初识 Vue.js 时的心理活动</title>
    <link href="http://note.xblame.top/2018/10/03/%E5%88%9D%E8%AF%86-Vue-js-%E6%97%B6%E7%9A%84%E5%BF%83%E7%90%86%E6%B4%BB%E5%8A%A8/"/>
    <id>http://note.xblame.top/2018/10/03/初识-Vue-js-时的心理活动/</id>
    <published>2018-10-03T07:51:37.000Z</published>
    <updated>2019-01-30T03:31:55.846Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在大学参与的小项目或者作业中总是当那个写后端的角色，前后林林总总用了各式框架和各种语言，包括java, python-flask, ruby on
        
      
    
    </summary>
    
      <category term="代码" scheme="http://note.xblame.top/categories/%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="vue" scheme="http://note.xblame.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>MRB主引导记录</title>
    <link href="http://note.xblame.top/2018/09/25/MRB%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/"/>
    <id>http://note.xblame.top/2018/09/25/MRB主引导记录/</id>
    <published>2018-09-25T07:08:13.000Z</published>
    <updated>2019-01-30T03:47:47.076Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;这几天因为一直在看操作系统和文件系统相关的书，了解到了MBR的作用的结构，记录一下。&lt;br&gt;MBR(master boot
        
      
    
    </summary>
    
      <category term="操作系统" scheme="http://note.xblame.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Archlinux 声音配置</title>
    <link href="http://note.xblame.top/2018/09/13/Archlinux-%E5%A3%B0%E9%9F%B3%E9%85%8D%E7%BD%AE/"/>
    <id>http://note.xblame.top/2018/09/13/Archlinux-声音配置/</id>
    <published>2018-09-13T00:08:07.000Z</published>
    <updated>2018-10-07T04:26:03.573Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Archlinux 通常使用alsa管理声音，需要安装alsa-utils包&lt;br&gt;安装完是默认静音的。需要执行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell line-numbers&quot;&gt;amixer sset Master
        
      
    
    </summary>
    
      <category term="疑难杂症" scheme="http://note.xblame.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="alsamixer,Archlinux,声音" scheme="http://note.xblame.top/tags/alsamixer-Archlinux-%E5%A3%B0%E9%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>grub 提示: Failed to connect to lvmetad……</title>
    <link href="http://note.xblame.top/2018/09/13/grub-%E6%8F%90%E7%A4%BA-Failed-to-connect-to-lvmetad%E2%80%A6%E2%80%A6/"/>
    <id>http://note.xblame.top/2018/09/13/grub-提示-Failed-to-connect-to-lvmetad……/</id>
    <published>2018-09-12T23:37:56.000Z</published>
    <updated>2018-10-07T04:23:36.543Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;编辑 /etc/lvm/lvm.conf&lt;br&gt;找到 use_lvmetad = 1&lt;br&gt;将其修改为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash line-numbers&quot;&gt;use_lvmetad =
        
      
    
    </summary>
    
      <category term="疑难杂症" scheme="http://note.xblame.top/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
      <category term="grub" scheme="http://note.xblame.top/tags/grub/"/>
    
  </entry>
  
  <entry>
    <title>Rails-理解</title>
    <link href="http://note.xblame.top/2018/09/11/Rails-%E7%90%86%E8%A7%A3/"/>
    <id>http://note.xblame.top/2018/09/11/Rails-理解/</id>
    <published>2018-09-11T04:34:24.000Z</published>
    <updated>2019-01-30T03:58:38.340Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;Rail
        
      
    
    </summary>
    
      <category term="代码" scheme="http://note.xblame.top/categories/%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="Rails" scheme="http://note.xblame.top/tags/Rails/"/>
    
  </entry>
  
</feed>
