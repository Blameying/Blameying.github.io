<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>After实习一个月</title>
      <link href="/2019/08/10/After%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%9C%88/"/>
      <url>/2019/08/10/After%E5%AE%9E%E4%B9%A0%E4%B8%80%E4%B8%AA%E6%9C%88/</url>
      
        <content type="html"><![CDATA[<p>这一年的七月初我走出校门，来到公司实习，到现在已经一个月了。感觉这一个月过的很快，变化很快，接触到的东西很多。可能就是因为太充实了，还没等我考虑时间，时间已经过去了，记录一下接触到的人和事，算是成长中的一份记忆备份。</p><p>七月四日，我来到苏州华为研究所实习，以下简称苏研所。坦言之，相比于其他互联网公司，华为的招聘确实很简单，更宽容一些，很多同学就是因为招聘太简单而不想来。其实非常容易理解他们的想法，人都愿意与更强的人为伍，见识了更厉害的人才会有新的视野作为自己的目标。我没有投递几家公司，春季找实习的时候，我不知道自己该做什么，想做什么。虽然喜欢计算机了很多年，但当要我一定要选择一个狭窄的方向时，一下茫然，仿佛是做了割舍。于是我开始分析，到底我哪方面更强一些？以前玩的开心，没想过这些，开始分析的时候就发现了问题，什么都会一些，具体到一个领域就有些不足了。我在嵌入式方面做的比较多，比较熟悉，但嵌入式的选择并不是很多，更何况当初玩嵌入式只是为了完整自己的知识体系，一旦要真的去做，又有些犹豫了。最后想要突击一下，做后端开发，毕竟自己是软件工程的，也做过不少全栈的小项目。实习面了阿里和腾讯，面试官问了一些算法和我没听过的概念，还有框架，问得我自闭。回头听大家推荐一些面试的书，看了以后才知道问的都是上面的问题，当时的心理感受无法言说，原来自己多年的热爱，自我发展，却不如好好针对面试准备，于是我好好按照套路准备了一番，却没有再尝试过去面试这两家公司，听说有人尝试了四遍进去了，很佩服他们这种坚持。接下来华为的笔试就很简单了，三道题我是都会的，题简单但是很繁杂，所以花了点时间核实，最后一道没时间做完。面试华为的时候，同样是后端的岗位，面试官对我做的比赛很感兴趣，于是我就聊嗨了，这个简直非常熟悉了，毕竟每行代码都是自己来的，付出过那么多日日夜夜。虽然那些比赛都是嵌入式的，面试官没有介意。所以，来华为实习了，非常感激这份机会。</p><p>第一个星期布置了一个小的任务，以前没接触过 maven 管理项目，但也就是个工具而已，用了半天摸清它的规律，解决了程序间的依赖问题，它的本地仓库和服务器仓库的设计是最直觉的设计，解决多项目的依赖问题岂不就是需要一个众所周知的地方。其实大部分时间都是摸清业务，因为这个任务并不是平地起高楼，而是往现有程序里添加功能，是一个新的需求了。自己写反而简单，添加功能就要摸清原有程序的脉络了。华为一般会给新入职的新人分配一个一对一的导师，我师父把脉很准，一直叫我理清业务。花了两天的时间读文档，把来龙去脉理了个清楚，两天时间代码写完测试完，按时在一个星期内完成了任务，回头一看，原来我是第一个做完的。看来长时间自己玩，虽然没能在某个领域专精，但针对问题的嗅觉和原理相通的理解，确实加速了我的学习过程，也算是自我安慰了，毕竟没有证据。</p><p>完成后，写了一篇非常详细的文档，于是同期的实习生就都看着我的文档做了，在第二个星期结束后大家都陆陆续续走出了任务的阴影，说实话，其实蛮有成就感的。大家也在彼此的问题交流中，变得熟悉了起来。师父比较严谨，对我的文档检查了两遍。这儿的人其实都很严谨，跨部门定位问题都会追踪到问题被解决才罢休，交给测试团队测试之前都要先内测清楚，如果有一个问题被模糊处理了，我是真的听到过有人吵架的，这便是商业化的严谨。</p><p>公司内的软件管理模式和自动化工具让我大开眼界，可惜这些都是保密的，就没办法写出来了。在学校的散漫环境里，我们是无法想象软件开发要变得如此精细，如此自动，如此工业化。版本管理工具的潜能被这样的多人多团队开发开发到了最大，叹为观止，见到了这些，我就彻底打消了直接读研的想法了。</p><p>师父人很好，是跑步协会的会长，每周三跟着他绕着附近的湖跑五公里，锻炼身体，欣赏美景，美哉。跑的时候我的肚子在颤，胸也在颤，真的胖了。在炎热的夏天，满身大汗，出乎意料的舒服。</p><p>完成文档后，师父说要接下来定位问题的时候都要带上我，然后叫我从小问题到大问题渐入佳境，说要玩起来。渐入佳境是他原话，我印象很深刻，因为那一刻我发现了师父有和我做技术时同样的快乐，这算是同道。于是开始跟着接入各种电话会议，甚至还会叫我组织，那几天压力山大，毕竟这里都是技术前辈，我一新人，哪敢说话。这样的状态没持续几天，师父就叫我自己来了，一方面是他真的很忙，一方面可能是给我的锻炼，他就和别人说让别人找我定位问题，赶鸭子上架，不行也得行啊，做技术的怎么能认怂，除了面试时我还真没认过怂。于是慢慢提出自己所有疑问，来来回回翻看日志，拉日志表现里可能出问题领域的人开会，给他们提供日志。这里有一点感受很深，就是大家真的都很忙，很多的问题待解决，你的问题只是其中一个，没定位之前你不能明确是别人的责任，我一开始就担心，一定要多催一催，别给整忘了，过了一天我觉得大家可能都忘了，心灰意冷之际，那晚十一点，定位问题的一个老哥给我发消息说定位了，是他们那边的问题，那一瞬间就感动了，我也没来得及催促，原来大家都在解决，没有推脱。于是第二天我换上他的补丁，进行验证，师父要求我一定要进行多次验证，不能只进行一次，这一次我执行的非常认真和赞同。气氛是很容易传递的，责任感是很容易传递的，你看着别人十一点交给你的劳动成果，绝不忍心轻视对待。</p><p>随后又解决了几个问题，终于在两个星期前领到了一个新需求，这代表我的代码有机会出现我们的产品上了。第一次开发对一些流程不熟悉，需求变更了三次，我也写了三次，其实并不是需求变更的错，而是我在确认之前太着急写，一定要沟通确认没有任何疑点后再开始开发，这点严谨是我在这个需求里最大收获，至于需求代码的难度，真的没有多少。我比较熟悉 git，但公司里用的并不完全是，所以周五晚上把写好测好的代码丢了，为了不耽误大家进度，我自觉的周六又来了公司，自己给自己挖的坑，再苦也要给填了啊～～</p><p>经过一个月的实习，自信了些，开心于之前的努力没有真的无形，从高中开始编程的累积，变成了更快的学习和适应。还认识了很多可爱的人，很多都是内网上解决问题认识的，纯技术交流，虽然没有见过面，但有时会关怀我 “这么晚了你怎么还没走，这个问题我给你解决，你先走吧。”</p><p>当然工作里并不是都有好，就像软件中的时间和空间无法得兼一样，工作中的效率和组织也是无法得兼的，人那么多，沟通耗掉了大部分时间。并且有的地方自动化还没有覆盖，程序员太多，代码的 clean 也很耗力量。</p><p>但工作真的很快，我一般每天晚上九点多回来，洗完澡就感觉累了，感觉自己原先计划的充实生活打在了空处。毫无疑问，我被工作带了节奏。这一个月，除了视野上有很大扩展和对工作更加适应，在自己喜欢的技术上，并没有很大进步，本想玩一下 RabbitMQ,也没有时间。</p><p>买东西开始考虑是不是必要，怕临走时丢掉浪费。</p><p>周末时渴望出去走走，一个人待在房子里感觉空气都像是死的一样，以前有舍友，就算大家不说话，起码知道房子里还有别人。而现在真真实实一个人，有种前所未有的寂寞，也许这也是我该学习的，学着不仅要在技术上自己驱动自己，也要去在心理上自我驱动，哈，做人有点难，也其乐无穷。</p><p>是有些怀念学校里的生活，那时候还不需要这样坚强的战斗，现如今看着学弟学妹们做竞赛，走我以前走过的路，真想对他们说一句，要玩的开心啊。这周五下班以后，回到住处，又看了一遍最后一部哈利波特，都这么大人了，却还是最喜欢这故事。一直觉得罗琳了不起，她很早就发现了勇敢才是真的决定性的品质，是人类最珍贵的品质，面对不可战胜，面对困难，面对苦难，面对机遇，都要勇敢啊。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下GNU开发ARM</title>
      <link href="/2019/04/21/Linux%E4%B8%8BGNU%E5%BC%80%E5%8F%91ARM/"/>
      <url>/2019/04/21/Linux%E4%B8%8BGNU%E5%BC%80%E5%8F%91ARM/</url>
      
        <content type="html"><![CDATA[<p>该篇实现的平台是:</p><ul><li>Archlinux kernel:5.0.7-arch1-1-ARCH</li><li>arm-none-eabi-gcc</li><li>stm32CubeMx version:5.1.0</li><li>STM32F429IGT6</li><li>openocd version: 0.10.0</li></ul><p>上述软件的安装不再叙述，不同的平台略有不同，在 Arch 下均可以通过源和 AUR 仓库安装。</p><h3 id="GNU-工具链和-Keil，IAR-的区别是什么？"><a href="#GNU-工具链和-Keil，IAR-的区别是什么？" class="headerlink" title="GNU 工具链和 Keil，IAR 的区别是什么？"></a>GNU 工具链和 Keil，IAR 的区别是什么？</h3><p>首先 GNU 是一条编译工具链，是相关必要开发工具的集合，而 Keil 和 IAR 都是集成开发环境，提供图形界面和良好的调试交互环境，同时里面都包含自己的编译工具链。Keil 和 IAR 会极大的提高我们的开发效率，使我们忽略一些重要但是比较通用的配置，比如工具链的编译参数和链接脚本。而使用 GNU 的难点也就是我们需要自己准备 Makefile 和 linkerscript。</p><h3 id="解决-Makefile-和-linkerscript"><a href="#解决-Makefile-和-linkerscript" class="headerlink" title="解决 Makefile 和 linkerscript"></a>解决 Makefile 和 linkerscript</h3><p>我们在使用 IDE（集成开发环境）时，不需要考虑多文件编程的依赖，只需要在使用的时候通过 Include 包含想要的头文件就行了。自己写 makefile 的时候就需要添加这些头文件的路径信息使得编译时可以找到我们使用的代码，并把所需的依赖自动加入编译参数中。同时编译器是支持很多内核架构和芯片类型的，这些参数也需要我们自己指定。Makefile 等同于我们 IDE 中项目配置的概念。</p><p>大部分人都知道在编译程序时有链接这个过程，但对其细节不太清楚，链接脚本文件以 ld 为扩展名，用来定义链接时每个段所应在的位置。比如我们在 ARM 编程中，需要把中断向量表放在起始位置，这便需要链接脚本的定义，可以将链接脚本看作一张地图，它定义了程序的每个部分该怎样安放。</p><p>这其实是使用 GNU 工具链的难点，对 Makefile 和 linkerscript 的精通无疑都需要花费很长时间。所以引出了我们使用的<em>STM32CubeMx</em>工具，这是一款 STM 芯片选型和工程生成的工具，它是跨平台的，通过它我们可以轻易的生成 Makefile 和 linkerscript。</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBIZz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--6a8300e63f45081719f590870698fde911132ca0/cubemx1.png" alt="主界面"></p><p>这是主界面，选择 ACCESS TO MCU SELECTOR 即可进入芯片选型界面，</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBIdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--8f0dcba9f610fb743c19e34bb1ca0aba72961537/2019-04-21%2011-27-31%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt="选择界面"></p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBJUT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--e213845e089810f68a57ad2fcd50acc4d8c4bbc4/2019-04-21%2011-29-09%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>选择好芯片型号后选择右上角 Start Project</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBJZz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--6f211d7acc8f4c53b60f31f6757b9fc2e4336801/2019-04-21%2011-31-25%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>Toolchain/IDE 一栏选择 Makefile,其他的可以根据自己需要配置，然后点击右上角 Generate Cide 生成代码。STM32CubeMx 的任务到此结束，接下来是 arm-none-eabi-gcc 的任务了。</p><h3 id="编译下载"><a href="#编译下载" class="headerlink" title="编译下载"></a>编译下载</h3><p>如果 arm-none-eabi-gcc 在环境变量里的话，Makefile 就不需要变动了，如果不在，需要自己指定路径</p><pre><code class="lang-makefile">GCC_PATH = /xxx/xxx</code></pre><p>此处改为你自己的路径，最后一级是 gcc 所在目录，而不是具体的可执行文件。<br>然后在该目录下执行 make 命令，输出信息最后几行显示了 elf,hex,bin 文件所在的目录。</p><p>我们使用 openocd 这一开源调试下载工具进行程序下载。<br>在 openocd 的安装文件夹中存在 script 文件夹，我的目录是/usr/share/openocd ,这个文件夹有对应不同下载方式和芯片的配置文件，interface 下面定义了使用的下载器，如下图:</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBJdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--cbe857f48c545e34ae2d4d4a161bf917b01c8965/2019-04-21%2011-41-37%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>可以在里面发现我们常用的 jlink,cmsis-dap,stlink 等下载方式，target 目录下则定义了一些芯片的配置。</p><p>然后我们连接好我们的开发板，我这使用的是 jlink-ob,swd 接口，所以我使用以下命令进行连接</p><pre><code class="lang-shell">openocd -f interface/jlink -c &quot;transport select swd&quot; -f target/stm32f4x.cfg</code></pre><p>因为这样怪麻烦，所以我建立了自己的配置文件</p><pre><code class="lang-shell">interface jlinktransport select swdsource [find target/stm32f4x.cfg]</code></pre><p>以后我就只需要执行</p><pre><code>openocd -f 我的配置文件路径</code></pre><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBKQT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--3c7935cbbdfde5cf6255ef7321643c3b777d9c50/2019-04-21%2011-49-08%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>连接成功后的信息。</p><p>openocd 会在系统的 4444 端口和 3333 端口开发两个服务，4444 端口用来执行一些指令，比如中断，恢复，刷写 flash 等等，3333 端口用来提供 gdbserver 服务，用来调试。这里我们先看一下如何下载</p><p>使用 telnet 连接 4444 端口</p><pre><code class="lang-shell">telnet 127.0.0.1 4444</code></pre><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBKUT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--b72a35c400445232aa766dc724a2a57b8a0fbc1b/2019-04-21%2011-54-13%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" alt=""></p><p>可以看到我输入了三个指令分别是</p><pre><code class="lang-shell">halt #中断单片机运行flash write_image erase ./build/STM32F429.hex #下载reset #重启</code></pre><p>程序下载完毕<br>为了方便，我也将下载写成了脚本，这样只要一个命令就可以实现编译下载</p><pre><code class="lang-shell">#!/bin/bashstty -echomake(echo &quot;halt&quot;echo &quot;flash write_image erase ./build/STM32F429.hex&quot;echo &quot;reset&quot;) | telnet 127.0.0.1 4444 &gt;/dev/nullecho &quot;Download finished!&quot;</code></pre><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>解决了下载了解一下调试，调试使用的是 arm-none-eabi-gdb 程序，</p><pre><code class="lang-shell">arm-none-eabi-gdb ./build/STM32F429.elf</code></pre><p>如果想要图形界面可以加—tui 参数<br>进入 gdb 以后要进行 gdbserver 的连接</p><p>输入</p><pre><code class="lang-shell">target remote 127.0.0.1:3333</code></pre><p>可以通过 monitor 对设备发送指令，在 arm 的调试里是没有 run 指令的，可以通过</p><pre><code class="lang-shell">monitor reset</code></pre><p>实现。如果需要回到程序起始位置并停留在那，可以</p><pre><code class="lang-shell">monitor reset halt</code></pre><p>其他的查看断点，设置断点，查看源码等操作和 pc 端 gdb 并无区别。</p><p>这篇只是描述了流程，接下来几篇可能会分析一下启动时的汇编代码和 linkerscript 内容编写。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux,arm,gnu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>借助cortex-m3内核理解单核多线程实现细节</title>
      <link href="/2019/04/11/%E5%80%9F%E5%8A%A9cortex-m3%E5%86%85%E6%A0%B8%E7%90%86%E8%A7%A3%E5%8D%95%E6%A0%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/"/>
      <url>/2019/04/11/%E5%80%9F%E5%8A%A9cortex-m3%E5%86%85%E6%A0%B8%E7%90%86%E8%A7%A3%E5%8D%95%E6%A0%B8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</url>
      
        <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>现代操作系统一般都是多进程的，这点我们已经见怪不怪了，计算机组成原理粗略的描述了多进程操作系统的实现方式，但总有些意犹未尽，这不能怪作者给我们留下悬念，毕竟进程的上下文切换是硬件相关的,因此必须具体到某个 CPU 的架构才可以在细节上描述。以前的我使用 cortex-m 系列单片机的时候都是在无操作系统环境下，代码的上下文切换都是中断，不存在应用程序和应用程序的上下文切换，归根结底是因为没有对于操作系统的强烈需求。最近在看 RT-Thread 的一些东西，重新觉得自己真正感兴趣的还是底层的原理，就像无法忍受雾里看花。于是在时间本应很紧张的时期拿起了 cortex-m3 的技术手册，比对着 RT-Thread 关于 m3 的线程切换代码，解决了一下心头痒。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>代码的运行实质上是 CPU 的不断取指，译码，执行，想要改变指令流可以通过当前指令修改待执行指令寄存器，也就是我们常说的 PC 指令计数器寄存器，我们常用的条件跳转语句，直接跳转语句都是基于这个的。但想设计多任务的程序需要多个任务彼此独立不说，还需要他们彼此切换，除非我们在每条语句后面都加一堆代码检测是不是有其他任务可以切换，否则单纯凭借上述功能是无法实现的。但好在我们还有中断这一硬件机制，中断可以打断当前的代码，跳转到中断服务程序里去，那也就是说我们可以在中断里进行其他任务检测和切换。<br>通过上述的条件，可以得到两种进程切换的思路:</p><ul><li>通过在当前任务申请主动切换</li><li>通过中断切换</li></ul><p>一个任务需要记录什么信息才能被恢复？</p><ul><li>首先要记录下一次恢复从哪执行</li><li>如果是在函数里要记录函数返回地址</li><li>既然提到了函数，一个任务或者进程或者线程应该有自己的函数栈，因此要备份自己的栈空间</li><li>使用变量什么的难免要用到常用的寄存器。</li></ul><p>不仅仅是多进程（多线程）需要这个，在进行中断跳转的时候，保护现场是必须的。因此很大程度上这些功能是重叠的。</p><h3 id="具体到-cortex-m3-上的细节"><a href="#具体到-cortex-m3-上的细节" class="headerlink" title="具体到 cortex-m3 上的细节"></a>具体到 cortex-m3 上的细节</h3><p>cortex-m3 在编写代码时，我们的 C 编程没有遇到过需要手写保护现场的代码，这也就导致很多新手甚至不知道保护现场的概念，事实上 cortex-m3 在进入中断的时候会自动将 <em>R0~R3,R12,PC（指令寄存器）,LR（函数返回地址）,PSR（程序状态寄存器）</em>寄存器入栈，在退出中断的时候自动出栈。值得注意的是 cortex-m3 中设计了两个栈寄存器，一个是 MSP 主栈寄存器，用在特权模式，也就是大部分中断环境，如果不设置应用模式的话，默认也是用这个。PSP 进程栈寄存器，只用在用户应用权限里。这里不对其权限设置做描述，主要是想写清楚上下文切换。</p><p>首先我们看一下 RT-Thread 的 线程结构:</p><pre><code class="lang-C">/* 线程控制块 */struct rt_thread{    /* rt 对象 */    char        name[RT_NAME_MAX];     /* 线程名称 */    rt_uint8_t  type;                   /* 对象类型 */    rt_uint8_t  flags;                  /* 标志位 */    rt_list_t   list;                   /* 对象列表 */    rt_list_t   tlist;                  /* 线程列表 */    /* 栈指针与入口指针 */    void       *sp;                      /* 栈指针 */    void       *entry;                   /* 入口函数指针 */    void       *parameter;              /* 参数 */    void       *stack_addr;             /* 栈地址指针 */    rt_uint32_t stack_size;            /* 栈大小 */    /* 错误代码 */    rt_err_t    error;                  /* 线程错误代码 */    rt_uint8_t  stat;                   /* 线程状态 */    /* 优先级 */    rt_uint8_t  current_priority;    /* 当前优先级 */    rt_uint8_t  init_priority;        /* 初始优先级 */    rt_uint32_t number_mask;    ......    rt_ubase_t  init_tick;               /* 线程初始化计数值 */    rt_ubase_t  remaining_tick;         /* 线程剩余计数值 */    struct rt_timer thread_timer;      /* 内置线程定时器 */    void (*cleanup)(struct rt_thread *tid);  /* 线程退出清除函数 */    rt_uint32_t user_data;                      /* 用户数据 */};</code></pre><blockquote><p><a href="https://github.com/RT-Thread/rt-thread/blob/master/include/rtdef.h" target="_blank" rel="noopener">https://github.com/RT-Thread/rt-thread/blob/master/include/rtdef.h</a></p></blockquote><p>RT-Thread 为每个线程维护了一个栈（数组），并没有单独维护一个寄存器状态表，因为在切换线程时寄存器的值都被压入了栈。</p><p>首先 RT-Thread 开启了 Systick 定时器中断，该定时器中断可以每隔固定时间触发一次，这会打断当前正在执行的线程，然后因为 cortex-m3 内核会自动备份必要的寄存器，将他们的值压入线程的私有栈（栈地址存放在栈地址寄存器）。此时在 Systick 检查是否有该切换的线程，如果有则触发 PendSV 中断，PendSv 中断是可被挂起中断，它的中断优先级被设定为最低的，这确保了它会在当前的所有中断请求执行完以后再执行。在 PendSV 中实现了栈地址的修改，即应用程序的上下文切换，这样在 PendSV 的中断服务函数结束以后，上下文会被自动切换到新的线程，寄存器会被自动填充。</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBHdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--4a693c90bf137da797c9e69fa0549e080d1ae274/pendsv.png" alt="示意图"></p><p>cortex-m3 进程切换的源码:</p><pre><code class="lang-asm">    PendSV_Handler:    /\*disable interrupt to protect context switch\*/    MRS R2, PRIMASK /\*备份中断屏蔽寄存器\_/    CPSID I /\*禁用除 NMI 和硬件错误之外的异常\*/    /\* get rt_thread_switch_interrupt_flag\*/    LDR     R0, =rt_thread_switch_interrupt_flag /*取变量地址*/    LDR     R1, [R0]                            /*取变量地址处的值*/    CBZ     R1, pendsv_exit         /* pendsv aLReady handled */ /*如果R1为0则跳转到pendsv_exit 防止重入*/    //clear rt_thread_switch_interrupt_flag to 0    MOV     R1, #0    STR     R1, [R0]    LDR     R0, =rt_interrupt_from_thread /*检测传入的当前线程是否为空*/    LDR     R1, [R0]    CBZ     R1, switch_to_thread    /* skip register save at the first time */    MRS     R1, PSP                 /* get from thread stack pointer */ /*将当前的线程栈地址传入R1*/    STMFD   R1!, {R4 - R11}         /* push R4 - R11 register */    /*cortex-m3 可以一次push或者pop多个数据，因为前面讲到自动压栈了一些寄存器，这里手动将其他的寄存器压栈*/    LDR     R0, [R0]    STR     R1, [R0]                /* update from thread stack pointer */ /*更新结构体内的栈指针，因为前面进行了压栈*/    switch_to_thread:    LDR R1, =rt_interrupt_to_thread //获得待切换到的线程结构体的地址    LDR R1, [R1] // 取得结构体地址存储的数据    LDR R1, [R1] /_ load thread stack pointer _//_ 因为存储的是个指针变量，因此再进行一次寻址 _/    LDMFD   R1!, {R4 - R11}         /* pop R4 - R11 register */ /* 将不会自动恢复的寄存器手动恢复 */    MSR     PSP, R1                 /* update stack pointer */    /* 加载新的栈指针，可以看到这里没有对结构体内的栈指针进行更新，没必要，在下次被切换出去时会被纠正 */    pendsv_exit:    // restore interrupt    MSR PRIMASK, R2 /\*解除中断屏蔽\*/    ORR     LR, LR, #0x04 /\*在中断服务函数中是使用MSP的，设置返回地址位，改为使用PSP\*/    BX      LR            /\*返回跳转\*/</code></pre><blockquote><p><a href="https://github.com/RT-Thread/rt-thread/blob/master/libcpu/arm/cortex-m3/context_gcc.S" target="_blank" rel="noopener">https://github.com/RT-Thread/rt-thread/blob/master/libcpu/arm/cortex-m3/context_gcc.S</a></p></blockquote><p>上面其实还有一个疑问，如何确保在结构体的地址中准确获得栈地址变量？<br>其实在作为 C 函数调用的时候传递的是这样的参数：</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBIQT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--8ce1a3b49f66f5e11da07dd9dde6547bd6e0acf3/context.png" alt="示意图"></p><p>所以在上文中关于汇编代码的解析中提到的结构体地址应该是结构体中栈的取地址。</p><blockquote><p>参考资料:</p><ul><li>《ARM Cortex-M3 权威指南》</li><li>GitHub RT-Thread 项目</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> context,switch,cortex-m,多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++析构函数-虚和非虚</title>
      <link href="/2019/03/20/C-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E8%99%9A%E5%92%8C%E9%9D%9E%E8%99%9A/"/>
      <url>/2019/03/20/C-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-%E8%99%9A%E5%92%8C%E9%9D%9E%E8%99%9A/</url>
      
        <content type="html"><![CDATA[<p>C++的类析构函数通常都是虚函数。这是因为虚函数是动态绑定的。如果一个类有可能成为基类则其析构函数必须为虚函数，如果不可能成为基类，则无所谓。实验如下:</p><pre><code class="lang-cpp">class A{public:    A(){        cout&lt;&lt;&quot;Init A&quot;&lt;&lt;endl;    }    ~A(){        cout&lt;&lt;&quot;Delete A&quot;&lt;&lt;endl;    }};class B:public A{public:    B(){        cout&lt;&lt;&quot;Init B&quot;&lt;&lt;endl;    }    ~B(){        cout&lt;&lt;&quot;Delete B&quot;&lt;&lt;endl;    }};</code></pre><p>A 为 B 的基类，A 的析构函数非虚。</p><pre><code class="lang-cpp">int main(){    B* b = new B();    delete b;    return 0;}</code></pre><p>Result:</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBHQT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--cec35615963cae95695b552c7f0de0c4bcc7a340/shot.png" alt=""></p><pre><code class="lang-cpp">int main(){    A* b = new B();    delete b;    return 0;}</code></pre><p>此处进行了修改，使用父类指针指向子类，这在编程中是非常常见的，结果就是出现了内存泄漏</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBHUT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--e47134da43d900935e9e8eacf3be613cb32c9a05/shot1.png" alt=""></p><p>C++对于非虚函数不会动态绑定,这在析构函数这也适用。<br>将 A 进行一些修改</p><pre><code class="lang-cpp">class A{public:    A(){        cout&lt;&lt;&quot;Init A&quot;&lt;&lt;endl;    }    virtual    ~A(){        cout&lt;&lt;&quot;Delete A&quot;&lt;&lt;endl;    }};</code></pre><p>结果：</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBHZz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--58477961c18a202816e0749a425e0b08607a3e4b/shot2.png" alt=""></p><p>将基类的析构函数设定为虚函数可以使得在任何父类指针指向子类时析构都能调用子类的析构函数，而子类的析构函数会正确释放内存。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++,析构函数,虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ new和malloc</title>
      <link href="/2019/03/20/C-new%E5%92%8Cmalloc/"/>
      <url>/2019/03/20/C-new%E5%92%8Cmalloc/</url>
      
        <content type="html"><![CDATA[<p>new 是 C++ 中的操作符，一般为类的实例变量分配内存，与之对应的内存释放函数是 delete,<br>malloc 是 C 语言的内存分配的函数，进行堆区已映射的内存的管理和采用系统调用增加内存映射区域。</p><h4 id="输入参数上的不同"><a href="#输入参数上的不同" class="headerlink" title="输入参数上的不同:"></a>输入参数上的不同:</h4><ul><li>new 不需要输入需要分配的 size,但 new 确实接受 size 参数，只是不需要手动填写。new 可以有多种<a href="https://code.woboq.org/gcc/include/c++/7.2.1/new.html#120" target="_blank" rel="noopener">重载</a>(overload)</li><li>malloc 需要人为计算需要分配的内存大小</li></ul><h4 id="返回值的不同"><a href="#返回值的不同" class="headerlink" title="返回值的不同"></a>返回值的不同</h4><ul><li>new 操作符返回指向实例化类类型的指针，申请失败时会持续调用 new_handler 回调函数，如果不存在 new_handler 函数则会抛出 bad_alloc 异常，因此针对 new 不需要检测是否分配成功。<a href="https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%2B%2B-v3/libsupc%2B%2B/new_opa.cc?revision=267494&amp;view=markup" target="_blank" rel="noopener">SRC</a></li><li>malloc 返回 void* 指针，需要强制类型转化为需要的指针,失败时返回 NULL，需要自己检测。</li></ul><pre><code class="lang-cpp">_GLIBCXX_WEAK_DEFINITION void *    operator new (std::size_t sz, std::align_val_t al)    {      std::size_t align = (std::size_t)al;      /* Alignment must be a power of two.  */      /* XXX This should be checked by the compiler (PR 86878).  */      if (__builtin_expect (!std::__ispow2(align), false))        _GLIBCXX_THROW_OR_ABORT(bad_alloc());      /* malloc (0) is unpredictable; avoid it.  */      if (__builtin_expect (sz == 0, false))        sz = 1;    #if _GLIBCXX_HAVE_ALIGNED_ALLOC    # ifdef _AIX      /* AIX 7.2.0.0 aligned_alloc incorrectly has posix_memalign&#39;s requirement       * that alignment is a multiple of sizeof(void*).  */      if (align &lt; sizeof(void*))        align = sizeof(void*);    # endif      /* C11: the value of size shall be an integral multiple of alignment.  */      sz = (sz + align - 1) &amp; ~(align - 1);    #endif      void *p;      while ((p = __gnu_cxx::aligned_alloc (align, sz)) == nullptr)        {          new_handler handler = std::get_new_handler ();          if (! handler)            _GLIBCXX_THROW_OR_ABORT(bad_alloc());          handler ();        }      return p;    }</code></pre><h4 id="分配内存位置的不同"><a href="#分配内存位置的不同" class="headerlink" title="分配内存位置的不同"></a>分配内存位置的不同</h4><ul><li>new 在<a href="http://www.gotw.ca/gotw/009.htm" target="_blank" rel="noopener">自由存储区</a>进行分配，<strong>自由存储区</strong>是 C++中的一个抽象层，并不是操作系统上给进程分配的空间存在叫做自由存储区的位置，作为一个抽象，它的底层可以指向堆区或者全局变量区。但也存在有的 C++库实现使用的是 malloc 在堆上直接分配</li><li>malloc 是在堆上分配存储的。</li></ul><h4 id="行为方式"><a href="#行为方式" class="headerlink" title="行为方式"></a>行为方式</h4><ul><li>new 在完成分配内存任务后会调用类的构造函数进行数据初始化，delete 在调用后会先调用析构函数，然后释放内存。</li><li>malloc 单纯分配内存，不做任何初始化，需要手动调用 memset 等函数赋予初始值</li></ul><h4 id="数组相关"><a href="#数组相关" class="headerlink" title="数组相关"></a>数组相关</h4><ul><li>new[] 会在分配内存后遍历调用构造函数,delete[] 会遍历调用析构函数</li><li>malloc 会直接清空数组的所有内存，不需要特殊指定。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++,new,malloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法学习-寻找最大子数组和</title>
      <link href="/2019/01/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2019/01/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>通过对算法导论的再次学习，重新温习了一些比较经典的算法问题。今天看的是寻找给定数组的最大连续子数组和，问题是这样的：在给出的一个数组中，找出相加和最大的连续子数组，例如在数组<em>A={-1,2,3,4,-3,1}</em>中，最大连续子数组为<em>{2,3,4}</em>。<br>脱离开实际问题的算法题目是比较无趣的，因为算法的发明是前辈们为了解决某些实际问题而思考而出的。《算法导论》中给出了一个有趣的例子，该例是给了17天的单支股票的每日结算价格，让求解出在哪一日买入，在哪一日卖出，我们能获得最大的收益。数据如下图：<br><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBGQT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--868f0a4e3a92971bed26c486db4e1c3686e03ef2/%E6%A0%87%E9%A2%98.png" alt=""></p><p>这是原始的结算数据，对其进行一下处理：将每一日的结算价格与前一日做差，这样数据就会变成该日的变化情况，比如图上数据处理后为</p><p><em>[0,13,-3,-25,20,-3,-16……………………]</em></p><p>得到的数组进行寻找最大子数组和，也就是等同于寻找最大收益，最大子数组的起点下标就是应该买入的日子，终点下标就是应该卖出的日子。</p><p>有以下三种方法计算：</p><ul><li>穷举</li><li>分治</li><li>动态规划</li></ul><h3 id="穷举"><a href="#穷举" class="headerlink" title="穷举"></a>穷举</h3><p>穷举的是把所有可能的子数组都寻找一遍，进行比较，此处不把子数组当成整体来考虑，而是考虑起点和终点的所有可能，并且起点一定小于或等于终点，可能的组合如图：<br><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBGUT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--7b0968ef35cead7e4f6bdc8d0c8668c1cf8a1b99/qiongju.png" alt="穷举"></p><p>计算[a,b]可以使用[a,a]的结果，因此每种情况只计算一次加法即可，共需要计算n+n-1+n-2+……+1次，即：$\frac{n(n+1)}{2}$<br>代码比较简单，就是简单的遍历计算即可</p><pre><code class="lang-C++">struct MaxSeq{    unsigned int start;    unsigned int end;    long  sum;};private:        int* sequence;        size_t size;public:        MaxSeq bruteForce() const{            MaxSeq result={0,0,this-&gt;sequence[0]};            for(unsigned int i=0;i&lt;(unsigned int)(this-&gt;size);i++){                long temp_in=0;                for(unsigned int j=i;j&lt;(unsigned int)(this-&gt;size);j++){                    temp_in+=sequence[j];                    if(temp_in&gt;result.sum){                        result.start=i;                        result.end=j;                        result.sum=temp_in;                    }                }            }            return result;        };</code></pre><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治思想是把大的问题同时拆分成很多小的问题，再把小问题求得的解进行合并计算从而获得大问题的解。<br>用分治算法来求解最大子数组和的算法是<br>求解数组最大子数组和</p><ol><li>如果数组长度大于1,将数组拆成两半，跳转到2，否则，返回唯一元素</li><li>对左数组求解数组最大子数组和，对右数组求解数组最大子数组和，求解跨越两个数组的最大子数组,到3</li><li>返回2中三个求解的最大结果</li></ol><p>很明显这是一个递归过程，拆分后的最大子数组可能在三个位置</p><ol><li>在左子数组</li><li>在右子数组</li><li>部分在左子数组，部分在右子数组</li></ol><p>示意图如下：<br><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBGZz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--d20dbb3239a1b0d851ff396376d8e19b6a1c83b0/guocheng.png" alt="过程图"></p><p>想起了手写数字识别，见谅：）<br>黑色箭头为拆分过程，红色为向上汇总时的选取操作，红色下标的为当前局部的最大子数组。<br>代码如下：</p><pre><code class="lang-C++">        MaxSeq DivideConquerParams(int* array,unsigned int start,unsigned int end) const{            MaxSeq result={start,start,array[start]};            if(start==end){                return result;            }else{                unsigned int middle = (end+start)/2;                MaxSeq left_result = DivideConquerParams(array,start,middle);                MaxSeq right_result = DivideConquerParams(array,middle+1,end);                MaxSeq between_result = findMaxSequenceBetweenTwoSubs(array,start,end,middle);                if(left_result.sum&gt;right_result.sum &amp;&amp; left_result.sum&gt;between_result.sum){                    return left_result;                }                if(right_result.sum&gt;left_result.sum &amp;&amp; right_result.sum&gt;between_result.sum){                    return right_result;                }                return between_result;            }        };        //求解跨越两个子数组的最大子数组        MaxSeq findMaxSequenceBetweenTwoSubs(int* array,unsigned int start,unsigned int end,unsigned int middle) const{            MaxSeq result={middle,middle,array[middle]};            long temp=0;            for(int i=middle;i&gt;=(int)start;i--){                temp+=array[i];                if(temp&gt;result.sum){                    result.start=i;                    result.sum=temp;                }            }            temp=result.sum;            for(unsigned int i=middle+1;i&lt;=end;i++){                temp+=array[i];                if(temp&gt;result.sum){                    result.end=i;                    result.sum=temp;                }            }            return result;        };</code></pre><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是解决这个问题速度最快的算法，时间复杂度是线性时间的。</p><blockquote><p>维基百科：<br>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p></blockquote><p>动态规划的关键在于重叠子问题和最优子结构，换言之局部最优和全局最优存在关系，可以通过局部最优减少得到全局最优的计算时间。<br>对于一个长度为N的数组A，已知<em>A[1，i]（1&lt;i&lt;n）</em>的最大子数组，则<em>A[1,i+1]</em>的最大子数组为<em>A[1,i]</em>的最大子数组或者<em>A[j,i+1]（1&lt;j&lt;i+1）</em></p><p>随着从前往后开始遍历数组，对所经过的数组进行求和，一旦和小于0则把之前的抛掉，重新设置当前点为起点，之所以把之前的全部抛掉而不是抛掉前半部分是因为，和小于0代表有负数元素，且负数元素的比重超过了正数，若负数元素主要分布在前半段，则根据规则，早就小于0了，绝对等不到现在，所以负数元素主要分布在后半段或均匀分布，所以只能全部抛掉。</p><p>动态规划的代码是最短的。</p><pre><code class="lang-C++">    MaxSeq dynamicProgram() const{            MaxSeq result={0,0,this-&gt;sequence[0]};            long temp=0,start = 0;            for(unsigned int i=1;i&lt;this-&gt;size;i++){                temp+=this-&gt;sequence[i];                if(temp&gt;result.sum){                    result.sum=temp;                    result.start=start;                    result.end=i;                }                if(temp&lt;0){                    temp=0;                    start=i+1;                }            }            return result;        };</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>设计模式理解到什么地步才叫理解呢，我阅历还浅，讲道理也是讲想象中的道理，难免中气不足。我觉得设计模式并不难，当一件事很复杂的时候，是很难看出到底是用哪种设计模式的，因为他可能什么模式都有，严格定义的话，又什么设计模式都不是,可能需要划分成很多小部分。就我而言，设计模式给了我一些思考的方向，甚至无形中改变了思考的模式，这就是比较大的收获。所有设计模式都必须学么？不是，有的设计模式是你自己在思考的过程中无形中就能用出来的，哪怕你不知道他是什么，这种本领比你能念出它的名字更重要。这些模式都很朴实，平易近人。</p><p>在日常生活中存在很多这样的场合，信息源向很多信息接收点传递信息，就像千家万户的电视，对于一个电视台，发布源其实只有一个。这个还不太明显，比如大家在聊天群的群聊，一旦有新的消息，每个人都会及时收到通知。大家都能想到，这应该是一个遍历的过程。观察者模式就适用于这种场合。</p><p>一个信息发布源，应该有以下功能：</p><ul><li>添加观察者</li><li>删除观察者</li><li>通知所有观察者信息</li></ul><p>所以把被观察的对象做成如下这样</p><pre><code class="lang-java">public interface Observable {    public Boolean attachObserver(MyObserver observer);    public Boolean removeObserver(MyObserver observer);    public void notifyAllObservers();}</code></pre><p>相应的对于观察者来说，要提供一个统一的方法来获取信息。</p><pre><code class="lang-java">public interface MyObserver {    public void update(String info);}</code></pre><p>假设有一家报社，要为用户提供新闻订阅业务</p><pre><code class="lang-java">//用户public class Order implements MyObserver{    private String name;    public Order(String name){        this.name = name;    }    public void update(String info) {        System.out.println(this.name+&quot;: &quot;+info);    }}//报社public class NewspaperOffice implements Observable{    private ArrayList&lt;MyObserver&gt; observers;    private String newspaper = &quot;&quot;;    public NewspaperOffice(){        observers = new ArrayList&lt;MyObserver&gt;();    }    public void attachObserver(MyObserver observer) {        observers.add(observer);    }    public void removeObserver(MyObserver observer) {        observers.remove(observer);    }    public void notifyAllObservers() {        for (MyObserver observer:observers){            observer.update(this.newspaper);        }    }    public void setNewspaper(String newspaper){        this.newspaper = newspaper;    }}</code></pre><p>这样，当我们有新用户需要添加的时候，</p><pre><code class="lang-java">public class Client {    public static void main(String[] args) {        MyObserver observer1 = new Order(&quot;observer1&quot;);        MyObserver observer2 = new Order(&quot;observer2&quot;);        NewspaperOffice newspaperOffice = new NewspaperOffice();        newspaperOffice.attachObserver(observer1);        newspaperOffice.attachObserver(observer2);        newspaperOffice.setNewspaper(&quot;This is a new message&quot;);        newspaperOffice.notifyAllObservers();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,观察者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>策略模式是一种选择，给一个灵活的接口，然后去选择，只要是这个接口下的子类，我们都能去选，在不同的场合，选择会不同，这就是策略。客户端或者是决策者，是依赖于这个接口的，而不依赖具体的实现。</p><p>如排序算法是有很多种的，所有排序算法都可以实现排序这个接口。</p><pre><code class="lang-java">public interface SortInterface {    public void sort(int[] data);}</code></pre><p>然后我们创建实现这个接口的具体类</p><pre><code class="lang-java">public class BubbleSort implements SortInterface{    public void sort(int[] data) {        //假装排序        //TO-DO 冒泡排序的逻辑    }}public class QuickSort implements SortInterface{    public void sort(int[] data) {        //假装排序        //TO-DO 快速排序的逻辑    }}</code></pre><p>可供选择的项已经做好了。<br>那么我们要做关于策略的选择了</p><pre><code class="lang-java">public class Client {    SortInterface sortTool = null;    public Client(SortInterface sortTool){        this.sortTool = sortTool;    }    public void doSort(int[] data){        if(this.sortTool!=null){            this.sortTool.sort(data);        }    }}</code></pre><p>策略模式让我凡是思考问题都一定要考虑接口结构。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-桥接模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>桥接模式是虚拟了一座“桥”，只不过这座”桥”的两端是抽象和实体。在维基百科用的是抽象的图形和画图的关系，我尝试找一中新的例子来两相比较促进理解。</p><p>鸟是会飞的，不同的鸟有不同的飞行姿态，当然有的不是鸟的也可以飞。所以建立一个飞行的接口</p><pre><code class="lang-java">public interface Flyable {    public void fly();}</code></pre><p>实现两种具体的动作</p><pre><code class="lang-java">public class FastFly implements Flyable{    public void fly() {        System.out.println(&quot;Fastly Fly&quot;);    }}public class SlowFly implements Flyable{    public void fly() {        System.out.println(&quot;Slowly Fly&quot;);    }}</code></pre><p>这是具体的那一部分，实现了具体的行为。</p><p>那在这个故事里谁是抽象的那一部分，可以是鸟，也可以是“能力”<br>这里我选择鸟。</p><pre><code class="lang-java">public interface Bird{    public void fly();}</code></pre><p>鸟拥有这样一种能力，而这种能力的具体实现我们已经分离出去了，接下来搭一个桥梁将其连接起来。</p><p>创建麻雀种</p><pre><code class="lang-java">public class Sparrow implements Bird{    private Flyable flyable = new FastFly();    public void fly() {        flyable.fly();    }}</code></pre><p>现在来看一下这个模式有啥用，桥接模式最大(个人理解)的好处是使得桥的两端可以单独变化而互不影响，不管比如具体端，飞行的具体方式不管如何实现，鸟只要调用fly就行了，这个是永远不变的，而鸟类的变化对飞行的具体方式也没影响，都是鸟类调用飞行。</p><p>感觉桥接模式无处不在。</p><p>一个简单的例子，以后有新的感受再来填坑。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,桥接模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>适配器并不是一个软件开发的专用术语，而是应用于生活的方方面面，一般用来提供不同接口之间的转接。例如下图：</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBEdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--189d423e8e56b7cd49a3b10646812576aed66af2/1348019735-2591968284.jpg" alt="水管适配"></p><p>这个可以使得不同粗细的水管接在一起。</p><p>又比如我们用的网线有一种接口，那么光纤解码器也是一种适配器。不变的是其中流动的数据，就像上图中不变的是流动的水。</p><p>在代码中，有时需要使用一些外部的资源，或者对已有的资源定义一种新的接口都可以应用适配器模式。我们不妨先定义一种接口</p><pre><code class="lang-java">public interface WeatherGet {        //通过城市名获得城市天气数据    public String getTheCityWeather(String city);}</code></pre><p>而原有的代码接口可能是这样的:</p><pre><code class="lang-java">public class CityWeather {    public String getWeather(int id){        String weather = &quot;&quot;;        //假设1是北京的id        switch (id){            case 1:                weather = &quot;北京： 晴&quot;;                break;            default:                weather=&quot;&quot;;        }        return weather;    }}</code></pre><p>看到这里我们不能重写一个CityWeather,因为那样会耗时耗力，这里有现成的，实在不想写，并且获取天气的代码可能是私有的</p><p>要不把接口改了? 可是我们不止从一个天气发布源获取天气数据，改了接口，以前的其他代码就不能用了。</p><p>这就是适配器的应用场合了，</p><pre><code class="lang-java">public class AdaptorForCityWeather extends CityWeather implements WeatherGet {    public String getTheCityWeather(String city) {        int weather_id = 0;        switch (city) {            case &quot;Beijing&quot;:                weather_id = 1;                break;            default:                    break;        }        if(weather_id!=0) {            return getWeather(weather_id);        }else {            return &quot;&quot;;        }    }}</code></pre><p>这样我们完全可以这么用了:</p><pre><code class="lang-java">WeatherGet weatherGet = new AdaptorForCityWeather();System.out.println(weatherGet.getTheCityWeather(&quot;Beijing&quot;));</code></pre><p>方法调用起来和其他的没什么两样，完全可以放进列表中循环调用。只要实现我们用的接口，我们就不需要关注其他的差异。</p><p>如果我们比较贪心，想要一个接口实现多个接口不同的已有类的功能怎么办，可以看到我们上面用的是继承，很多语言是不支持多继承的，比如java</p><p>这样可以用关联的方式，通过生成旧类的变量来实现那么上面的接口类可以略作修改</p><pre><code class="lang-java">public class AdaptorForCityWeather implements WeatherGet {    public String getTheCityWeather(String city) {                CityWeather cityWeather = new CityWeather();        int weather_id = 0;        switch (city) {            case &quot;Beijing&quot;:                weather_id = 1;                break;            default:                                                                          break;                                                        }        if(weather_id!=0) {                                                           return cityWeather.getWeather(weather_id);        }else {            return &quot;&quot;;                                                            }                                                                     }}</code></pre><p>用的例子是比较简单的适配器，我觉得以后遇到复杂的顺着这种思路应该能够理的清。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式，适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-抽象工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>走过了简单工厂模式和工厂模式，我来了解一下抽象工厂模式，现在已经知道“工厂”二字的含义了，就是帮别人建造对象，想想JDBC(数据库连接库)中用到的getConnection之类的方法，这就是工厂模式的应用啊。但是简单工厂模式和工厂模式都存在那个添加和修改必须更改以前代码的问题，这是不符合开闭原则的，也不是我们非要鸡蛋里挑骨头，而是在大体量的项目中，能不重新编译就不重新编译，能不引入更多变数就不引入更多变数，更希望的是像vscode编辑器的插件一样，这样的扩展性让人很舒服，开发者不需要修改官方的源码，每个人都可以互相不影响的开发插件。</p><p>那么如何令工厂模式符合开闭原则呢，能不能我从配置文件中动态获取类的名称然后自动的选择调用哪个工厂呢，当然可以。</p><pre><code class="lang-java">MapFactorys myMap = Class.forName(&quot;MapAFactory&quot;).newInstance();</code></pre><p>当提供的参数变成字符串的话，我们的可操作性就变大了。其实用Ruby这样的元编程语言能把工厂模式做的更好。</p><p>接下来看一下抽象工厂模式<br>工厂模式和抽象工厂模式最大的区别就是</p><ul><li>工程模式面向单个层面的产品</li><li>抽象工厂模式面向多个层面的产品</li></ul><p>一个游戏肯定不止有地图，这个地图上得有对应的野怪，得有对应的据点吧，得有杂七杂八的其他东西，我们前面已经这么较真设计了，肯定忍受不了这么多东西都把责任扔在地图身上。<br>一个工厂可不可以在建立地图的时候，把这张图对应的各个品种的野怪和各个类型的据点(建筑物)给搞定呢。</p><p>在原来的代码的基础上添加Monster相关</p><pre><code class="lang-java">//Monster 接口public interface Monster {    public void say();}public class MonsterA implements Monster{    public void say() {        System.out.println(&quot;I am Monster A&quot;);    }}public class MonsterB implements Monster {    public void say() {        System.out.println(&quot;I am Monster B&quot;);    }}</code></pre><p>修改一下工厂相关</p><pre><code class="lang-java">public interface Factorys {    public static Factorys getFactory(String select){        Factorys factorys = null;        switch (select){            case &quot;FactoryA&quot;:                factorys = new FactoryA();                break;            case &quot;FactoryB&quot;:                factorys = new FactoryB();                break;            default:                factorys =null;        }        return factorys;    }    public Monster getMonster();    public GameMap getGameMap();}public class FactoryA implements Factorys {    public Monster getMonster() {        return new MonsterA();    }    public GameMap getGameMap() {        return new MapA();    }}public class FactoryB implements Factorys{    public Monster getMonster() {        return new MonsterB();    }    public GameMap getGameMap() {        return new MapB();    }}</code></pre><p>其实从这里就可以看出，抽象工厂模式并没有更优秀，只是和工厂模式适合的场合不一样，这里的FactoryA 和 FactoryB 其实是不同的生产组合。</p><p>客户端代码</p><pre><code>import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;        Monster monster = null;        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            Factorys f = Factorys.getFactory(selected);            monster = f.getMonster();            map = f.getGameMap();        }        if(map!=null &amp;&amp; monster!=null) {            map.draw();            monster.say();        }    }}</code></pre><p>如果我们添加一个新品种的怪物或者新的地图又或者新的一种组合，都可以通过添加该产品接口下的类和新的工厂类，如果配合一开始所说的Class.forname方法，可以满足开闭原则，但要是我要加入据点这一新的种类呢，亦或者说这一新的层次呢，那我所有的已有的工厂都需要新加一个方法，getXXXX，所以是不满足开闭原则的。真正体会到了设计模式只是提供一种解决问题的思路，没有什么所谓的标准定式，需要根据实际的情况选择和改变。所以真正有意义的是前人这种思考的方式。<br>看后面能不能用ruby实现一个更优美的工厂方法吧。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>上一篇遗漏了一些问题，工厂模式特别适合那种创建比较复杂的对象，这样将创建的任务交给其他部分，使得客户端代码更简介，调用更方便。后来者少写代码，减少代码的重复，提高复用性。<br>简单工厂模式比工厂模式简单，但工厂模式是简单工厂模式的进化么？我觉得不是，因为该少的东西一点都没少，那工厂模式多了什么？</p><p>工厂模式的思路大概是这样的，还用上一篇游戏地图的例子，每一个地图所需要的参数和定制有可能是不一样的，要不要为每一个地图单独适配一个自己专门的工厂呢，我们把复杂的创建逻辑放在属于这个地图的工厂里，那这样，彼此的工厂不会混乱，地图本身的类也更符合一个模型的结构。这就是工厂模式，为每一个地图创建一个单独的工厂。</p><p>那么依据面向接口编程的原则，给出地图的代码</p><pre><code class="lang-java">//定义统一的调用接口public interface GameMap{    public void draw();}//普通地图类 A 和 Bpublic class MapA implements GameMap{    public void draw(){        System.out.println(&quot;This is MapA&quot;);            }}public class MapB implements GameMap{    public void draw(){        System.out.println(&quot;This is MapB&quot;);    }}</code></pre><p>接下来是工厂类的结构</p><pre><code class="lang-java">//工厂的接口public interface MapFactorys {    public static MapFactorys createFactory(String selected){        MapFactorys mapFactorys = null;        switch (selected){            case &quot;MapAFactory&quot;:                mapFactorys = new MapAFactory();                break;            case &quot;MapBFactory&quot;:                mapFactorys = new MapBFactory();                break;                default:                    mapFactorys = null;        }        return mapFactorys;    }    public GameMap createMap();}//具体的工厂public class MapAFactory implements MapFactorys{    public GameMap createMap() {        return new MapA();    }}public class MapBFactory implements MapFactorys{    public GameMap createMap() {        return new MapB();    }}</code></pre><p>确实，单一工厂只生产单一产品，在这里就是只生产单一的地图。<br>客户端的逻辑基本不需要变。</p><pre><code class="lang-java">import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            map = MapFactorys.createFactory(selected).createMap();        }        if(map!=null) map.draw();    }}</code></pre><p>这样改的好处目前是看不来的，这是因为没看到我们用工厂生产一个东西有多么复杂，试想如果构建一个东西需要很多先决条件呢，也就是必须分为几步的话，不同的地图，这几步还不一样的话，工厂模式的好处就会体现出来，成功的分离了产品和产品之间的变化点。</p><p>但是工厂模式仍然有比较大的麻烦，相信大家也发现了，在工厂接口中的静态方法，免不了还是一堆的条件判断。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-简单工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>公认的有理之言已经被传递的铺天盖地，不多我一个传播者，所以我说一下自己的思考，还希望看到的人对有错存疑之言不吝赐教。</p><p>设计模式是在实践中总结出的做出更好的软件的一些方法，什么是更好的软件，就我看来是在当前基础上不管是修改还是添加，都能给开发者省点力气的软件。能做到这点就足以说明这个软件的结构很好，并且在开发的时候不仅考虑了眼下的事情，还考虑了将来的事。应用设计模式的代码不一定性能更优，不一定代码更少，这取决于代码的体量和计划中的生存周期。</p><p>我们玩游戏一般都会有各种各样的地图，我们可以灵活的在各种地图之间切换,那么一般直觉的设计是下面这样的:</p><pre><code class="lang-java">public class Client{    //客户端类    //在这里接受用户输入    //判断输入是哪种地图，然后生成指定的地图。    /*        switch(选择)        {            case XX :          ............        }    */}</code></pre><p>相信上面的简明代码大家都能看懂，这个代码一看上去是没有问题的，不妨多想一步，我每次增加或者修改地图，都需要重新修改客户端代码，一是容易污染客户端代码，随着地图的增加，开发者对客户端代码编辑次数增加，难免会误动其他代码，或者多个人同时需要修改不同的东西，而这些东西都在客户端，同步问题，版本控制问题就会都暴露出来，由此可见，这不是客户端应该干的事，我们应该把选择地图这件事分离出来。</p><p>容易想到，我们建立一个单独的类，客户端只负责给它想要的类的名字，产生地图的细节和根据名字做出判断都交给这个类来做，那事情是不是就解决了? 客户端中获知这些类叫什么，有多少地图，这都是非代码信息，完全可以用配置文件或者用户输入来解决，也就是说我们让客户端真正分离出去了，再也不用修改客户端。代码示例如下</p><pre><code class="lang-java">//定义统一的调用接口public interface GameMap{    public void draw();}//普通地图类 A 和 Bpublic class MapA implements GameMap{    public void draw(){        System.out.println(&quot;This is MapA&quot;);            }}public class MapB implements GameMap{    public void draw(){        System.out.println(&quot;This is MapB&quot;);    }}//负责处理地图选择的逻辑public class GameMapFactory{    private static GameMap map;    public static GameMap getMap(String selected){        switch (selected){            case &quot;MapA&quot;:                map = new MapA();                break;            case &quot;MapB&quot;:                map = new MapB();                break;            default:                map = null;                break;        }        return map;    }}import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;                //地图名可以从输入得到，但更合适的是从配置文件得到。        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            map = GameMapFactory.getMap(selected);        }        if(map!=null) map.draw();    }}</code></pre><p>这样我们每次扩展或者修改的时候只需要单独修改 GameMapFactory 的源码就可以。 然而等到地图多了，这里面的代码仍然会不太优美。所以人们又想出了工厂模式。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux 安装.net core</title>
      <link href="/2018/10/16/Archlinux-%E5%AE%89%E8%A3%85-net-core/"/>
      <url>/2018/10/16/Archlinux-%E5%AE%89%E8%A3%85-net-core/</url>
      
        <content type="html"><![CDATA[<p>从Arch源安装:</p><pre><code class="lang-bash">sudo pacman -S dotnet-sdk</code></pre><p>这个时候已经安装了.net core<br>找一个心仪的存放工程的目录</p><pre><code class="lang-bash">dotnet new mvc --auth Individual -o YouProjectName</code></pre><p>这里的几个参数解释一下，new 是创建新工程，类似于django，rails创建工程时的模式。<br>mvc是指建立web工程，—auth是认证方式，这里几个可选的参数，具体说明参见<a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21" target="_blank" rel="noopener">MSDN</a><br>一般教程讲到这就是运行工程了</p><pre><code class="lang-bash">cd YouProjectNamedotnet run</code></pre><p>但是在我这边出了些问题，提示如下：</p><blockquote><p>System.InvalidOperationException: Unable to configure HTTPS endpoint. No server certificate was specified, and the default developer certificate could not be found.To generate a developer certificate run ‘dotnet dev-certs https’. To trust the certificate (Windows and macOS only) run ‘dotnet dev-certs https —trust’. For more information on configuring HTTPS see <a href="https://go.microsoft.com/fwlink/?linkid=848054" target="_blank" rel="noopener">https://go.microsoft.com/fwlink/?linkid=848054</a>.</p></blockquote><p>解决方案如下：</p><pre><code class="lang-bash">dotnet tool install --global dotnet-dev-certs</code></pre><p>然后执行</p><pre><code class="lang-bash">dotnet dev-certs https</code></pre><p>如果提示错误：</p><blockquote><p>A fatal error occurred, the required library libhostfxr.so</p></blockquote><p>接下来设置环境变量</p><pre><code class="lang-bash">export DOTNET_ROOT=/opt/dotnet</code></pre><p>重新执行出错的那句。</p><p>可以把设置环境变量的语句放入<br>~/.bashrc 或者 ~/.xprofile文件，这样就不需要每次手动加载了。</p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux,dotnet core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux安装Boost库</title>
      <link href="/2018/10/16/Archlinux%E5%AE%89%E8%A3%85Boost/"/>
      <url>/2018/10/16/Archlinux%E5%AE%89%E8%A3%85Boost/</url>
      
        <content type="html"><![CDATA[<p>Archlinux 软件源中有boost 不需要自己编译安装。</p><pre><code class="lang-bash">sudo pacman -S boost</code></pre><p>刷新一下当前环境</p><pre><code>ldconfig</code></pre><p>新建立一个代码文件，测试一下boost库是否安装成功了。</p><pre><code class="lang-cpp">#include &lt;boost/timer.hpp&gt; //boost库统一用hpp#include &lt;iostream&gt;using namespace boost;using namespace std;int main(){    timer t;    cout &lt;&lt; &quot;max timespan:&quot; &lt;&lt; t.elapsed_max() / 3600 &lt;&lt; &quot;h&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;min timespan:&quot; &lt;&lt; t.elapsed_min() &lt;&lt; &quot;s&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;now time elapsed:&quot; &lt;&lt; t.elapsed() &lt;&lt; &quot;s&quot; &lt;&lt; endl;}</code></pre><p>编译的时候按照gnu的编译规矩要手动指定库文件</p><pre><code class="lang-bash">g++ source_filename.cpp -lboost_timer -o execute_filename</code></pre><p>这里用-lboost_timer是因为我们用到了timer头文件。用其他库要改成-lboost_xxx</p>]]></content>
      
      
      <categories>
          
          <category> Boost </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boost,Archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 Vue.js 时的心理活动</title>
      <link href="/2018/10/03/%E5%88%9D%E8%AF%86-Vue-js-%E6%97%B6%E7%9A%84%E5%BF%83%E7%90%86%E6%B4%BB%E5%8A%A8/"/>
      <url>/2018/10/03/%E5%88%9D%E8%AF%86-Vue-js-%E6%97%B6%E7%9A%84%E5%BF%83%E7%90%86%E6%B4%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>在大学参与的小项目或者作业中总是当那个写后端的角色，前后林林总总用了各式框架和各种语言，包括java, python-flask, ruby on rails,总觉得视觉设计很炫酷，视觉的美感比较直接和强烈，也更容易被人共鸣。你想一个普通人看到你写的代码是不可能说：哇，这真是太美了。这点真的很难，很多写代码很多年的人也不会有这种美感。所以说这么多，总而言之，我想学一些前端，不是为了工作，而是为了自己在自娱自乐的时候用更多发挥的空间。</p><p>以前也看过javascript,html,css的相关知识，但你要说实战的时候能信手拈来还差的远。但这个东西吧，思想上很难接触，html，css是纯标记的语言，让人感觉死板和本身的工具性特别浓厚。排版啊，样式啊，是这些东西，而不是传统后端的逻辑。我不太想学javascript，可能是我从它的形式里很难找到美感吧，个人感受。</p><p>在合作完成作业的时候，做前端的同学用到了vue.js，我虽然早有耳闻，但没有这种亲身接触的印象深刻。首先，我觉得这个框架设计的很清晰，解决了很多人们不需要关心的问题。于是我去<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue官网</a>看完了大半的文档。但是，却难以有整体的把握，后来在youtube上看了个60分钟介绍的短片，又自己做了一个toy project，这才感觉可以上手了。</p><p>那么说一下当下的理解。</p><p>关于v-if v-for之类的在理解上没有什么问题。关键是模板模块和路由。vue为了提高代码的重复利用，允许用户把代码分成一个个模块，那么在构建一个新的网页的时候如果有需要的组件可以直接拿过来用。一个网站的不同网页为了保持样式的统一肯定有很多部分需要在不同的网页中重复利用，这样可以直接在父元素中包含这个组件。组件之间允许嵌套。组件之间可以通过props传递变量。每一个组件就是一个小的页面，在这个组件的vue文件中可以直接定义自己js和css。使得整个工程的结构清晰。一张网页就可以看成一张画纸，组件就是拼图，就看怎么摆放了。<br><br><br><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBDQT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--9d8daffc97fba3c799b11d7033c19cd94ac9d456/timg%20\(1\" alt="">.jpeg)<br><br><br>做的一个样例，列表内容临时去<a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a>摘的，应该看不清吧。</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBDUT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--bab84b20863c01a09f1206f9b24901c481c4adcf/vu1.png" alt=""></p><pre><code class="language-javascript line-numbers">&lt;template&gt;    &lt;div class="HomePage"&gt;        &lt;div class="person"&gt;            &lt;img class="headico" v-bind:src="user.headico"&gt;            &lt;h3 class="username"&gt;{{user.username}}&lt;/h3&gt;            &lt;p&gt;{{user.info}}&lt;/p&gt;        &lt;/div&gt;        &lt;articlelistitem&gt;&lt;/articlelistitem&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ArticleListItem from './ArticleListItem.vue'export default {  name: 'HomePage',  data () {    return {      user: {        headico: 'http://img4.duitang.com/uploads/item/201411/09/20141109142633_ncKBY.thumb.700_0.jpeg',        username: 'Xblame',        info: '一个简单的读书人'      }    }  },  components: {    'articlelistitem': ArticleListItem  }}&lt;/script&gt;&lt;style scoped&gt;.headico {    width: 100px;    height: 100px;    border-radius: 50px;}&lt;/style&gt;</code></pre><p>这其实是一个HomePage的组件，就是图上的用户头像，姓名，信息那一块。下面的列表是一个单独的模块ArticleListItem，HomePage中引用了它。</p><p>一个网站的路由是比较核心的功能，路由就是通向一个网页的链接，比如对于一个母版的网页，中间包含了一个组件，那么针对不同的链接可以通过路由更换其中的组件，首先vue有一个总的路由，这个路由可以通向各个大的组件，但一个复杂的网页中，大的组件势必包含一些小的组件，这个时候需要嵌套路由。举个例子：</p><p><strong>访问一个网站的域名，也就是访问其根目录，首先route根据你定义的根目录渲染那个模块，如果这个模块还包含一个&lt;router-view/&gt;的路由入口,比如你想让ArticleListItem插入在这，你就需要访问/articlelistitem,即在父组件的路由路径后加上自己的路由路径。</strong></p><p>不建议嵌套很多层，根据在其他领域得到的经验。层次结构超过一定限度会极大增加复杂度，尽可能转化成平面结构。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MRB主引导记录</title>
      <link href="/2018/09/25/MRB%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/09/25/MRB%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>这几天因为一直在看操作系统和文件系统相关的书，了解到了MBR的作用的结构，记录一下。<br>MBR(master boot record)主引导记录位于存储设备的绝对零扇区，这里的绝对零扇区是指物理上的起点。MBR整个结构共占用<strong>512</strong>Byte。接下来用一个C语言结构体来表示一下</p><pre><code class="language-c line-numbers">struct MBR{    uint8 PartCode[446];    //MBR引导程序    struct Partition DPT[4];    //四个分区信息    uint8 BootSectSig0;     //55    uint8 BootSectSig1;     //AA};/* 55 AA 在最后两个字节，小端字序，真实值为AA55,代表正常扇区结束。*/struct Partition{    uint8 Active;   //引导指示符，指明次分区是否是活动分区，取值为0x80，说明可以引导操作系统，通常取0    uint8 StartHead;    //分区的开始扇头    uint16 StartCylSect;    //开始柱面和扇区，前6位为开始扇区，后10位为开始柱面    uint8 PartType;     //分区类型    uint8 EndHead;  //分区的结束头    uint16 EndCylSect;  //结束柱面与扇区，前6位为结束扇区，后10位为结束柱面    uint32 StartLBA;    //分区的第一个扇区地址    uint32 TotalSector; //分区的总扇区数};</code></pre><blockquote>  该处出自 《嵌入式FAT32文件系统设计与实现》于振南 编著</blockquote><p>DPT(Disk Partition Table ) 磁盘分区表</p><p>开始的446个字节的是一段引导代码。简单来说是一段 程序，在计算机上电以后，<a href="https://baike.baidu.com/item/bios" target="_blank" rel="noopener">BIOS</a>(Base Input Output System 基本输入输出系统)会自动读取MBR的前446个字节，然后执行这段代码，这段代码会对mbr区后面的分区信息的代码进行读取分析，找到分区信息，根据分区信息找到需要引导的操作系统的程序，进而启动操作系统。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux 声音配置</title>
      <link href="/2018/09/13/Archlinux-%E5%A3%B0%E9%9F%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/13/Archlinux-%E5%A3%B0%E9%9F%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Archlinux 通常使用alsa管理声音，需要安装alsa-utils包<br>安装完是默认静音的。需要执行</p><pre><code class="language-shell line-numbers">amixer sset Master unmute</code></pre><p>如果提示：amixer: Unable to find simple control ‘Master’,0<br>则表示不能找到声卡设备需要继续配置<br>执行命令获取声卡的声卡ID和设备ID</p><pre><code class="language-shell line-numbers">aplay -l</code></pre><p>结果如下</p><pre><code class="language-shell line-numbers">**** List of PLAYBACK Hardware Devices ****card 0: HDMI [HDA Intel HDMI], device 3: HDMI 0 [HDMI 0]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 7: HDMI 1 [HDMI 1]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 8: HDMI 2 [HDMI 2]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 9: HDMI 3 [HDMI 3]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 10: HDMI 4 [HDMI 4]  Subdevices: 1/1  Subdevice #0: subdevice #0card 1: PCH [HDA Intel PCH], device 0: ALC282 Analog [ALC282 Analog]  Subdevices: 0/1  Subdevice #0: subdevice #0</code></pre><p>把下列配置添加到系统级别的 /etc/asound.conf 或用户级别的 ~/.asoundrc 文件。如果文件不存在，可以手动创建。其中的各个ID，根据实际情况调整：</p><pre><code class="language-shell line-numbers">defaults.pcm.card 1   #根据上面输出的信息，ALC282是我的设备，选择card=1defaults.pcm.device 0 #device 为0defaults.ctl.card 1  #决定哪个声卡能由alsamixer控制</code></pre><p>同时，对于i3wm,fluxbox之类的wm（窗口管理器），而不是DE(Desktop environment),往往需要自己设置音量快捷键<br>这里给出i3的例子（编辑~/.config/i3/config）文件</p><pre><code class="language-shell line-numbers">#设置静音bindsym XF86AudioMute exec "amixer -q sset Master,0 toggle"#设置音量调节bindsym XF86AudioRaiseVolume exec --no-startup-id  amixer -c 0 set Master 3%+bindsym XF86AudioLowerVolume exec --no-startup-id  amixer -c 0 set Master 3%-</code></pre>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alsamixer,Archlinux,声音 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grub 提示: Failed to connect to lvmetad……</title>
      <link href="/2018/09/13/grub-%E6%8F%90%E7%A4%BA-Failed-to-connect-to-lvmetad%E2%80%A6%E2%80%A6/"/>
      <url>/2018/09/13/grub-%E6%8F%90%E7%A4%BA-Failed-to-connect-to-lvmetad%E2%80%A6%E2%80%A6/</url>
      
        <content type="html"><![CDATA[<p>编辑 /etc/lvm/lvm.conf<br>找到 use_lvmetad = 1<br>将其修改为</p><pre><code class="language-bash line-numbers">use_lvmetad = 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rails-理解</title>
      <link href="/2018/09/11/Rails-%E7%90%86%E8%A7%A3/"/>
      <url>/2018/09/11/Rails-%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Rail 核心目录在于app下面的model,controller,view<br><br><br>是经典的MVC结构，以Model数据为中心，Model通过ActiveRecord模块与数据库连接，不需要自己在Model里定义变量和getter，setter之类的在java中常写的存取函数，只需要在db/migrate目录中定义同名数据库表，接下来便开始忽略与数据库相关的事，暂时将其透明化。controller负责定义一系列与数据相关的动作，组织数据，生成视图。即负责链接数据和视图。<br><br><br>route.rb 负责链接url和controller</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBFdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--76b16363b144860046c8c3790ae4e27a5b6ab37a/10-03-3.jpgrails%E7%90%86%E8%A7%A3.png" alt=""></p><p>view 中指定的视图应当与其在controller中对应的动作存在共享实例变量和几个全局变量，进行数据的交互。</p><p>controller 和 view 的对应关系，model和数据库的对应关系使用约定。一开始觉得体系庞大，难以掌控，我觉得不妨先观察，然后思考，不知所以然的照着教程写一遍不利用后面摆脱固定的模式限制进行自定义。不妨多些勇敢，多尝试，不用觉得与示范做法不一样，这样才能真正的使用。</p><hr><p>以下内容补充自 2019-1-30 11:53</p><p>rails 存在很多自己的DSL，包括各种不同的插件也实现了自己的DSL，使我有时会摸不着头脑，按照惯常的思维会去查阅大量资料试图理解他的工作原理，然后才知道该怎么去实现我想要的功能，说实话这个框架现在有些“重”，渐渐变得不快乐。实际上我还是在用C语言之类的强类型语言的思维试图掌控所有细节。也许在使用ruby和rails时学会放手，能更舒服一些，慢慢的用的多了自然而然就理解了。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rails </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 类中方法参数 self</title>
      <link href="/2018/09/06/python-%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-self/"/>
      <url>/2018/09/06/python-%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-self/</url>
      
        <content type="html"><![CDATA[<h3>内存</h3><p>Python 类在内存中的实现是类有自己的一个空间，存放类中的定义的变量和方法，在声明一个实例的时候，为该实例分配一块新的空间，但仍有引用指向类，这也是大部分面向对象的设计方法，对大家都有的东西只存在一份。当实例变量中的变量绑定新的值，或是方法覆写这些自己独有的东西存放在自己的空间里。当多个实例变量去访问同一个函数，这个函数如果没有被覆写应当是在类空间里的。那这个方法自然而然就需要区分是哪个实例调用的自己。在这里，python为了精确，需要手动声明这个需要传递的实例的引用。</p><h3>为什么是self?</h3><p>self其实是一种约定俗称的写法，因为传递实例变量引用的这个过程是自动的，python会自动把引用填入第一个参数，所以，python类的实例方法至少接受一个参数。python只接受第一个参数，而不管这个参数的名字，所以可用任何一个单词替换self，但self意义比较明显，所以大家习惯用self。</p><blockquote>  Often, the first argument of a method is called self. This is nothing more than a convention: the name self has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention  ----Python Document</blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> class,python,self </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rails 多对多 自联结 建立好友关系表</title>
      <link href="/2018/09/03/Rails-%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E8%87%AA%E8%81%94%E7%BB%93-%E5%BB%BA%E7%AB%8B%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E8%A1%A8-md/"/>
      <url>/2018/09/03/Rails-%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E8%87%AA%E8%81%94%E7%BB%93-%E5%BB%BA%E7%AB%8B%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E8%A1%A8-md/</url>
      
        <content type="html"><![CDATA[<h3>Model</h3><pre><code class="language-Ruby ">class User &lt; ApplicationRecordhas_many :a_friends, class_name: "Friendship",foreign_key: :request_friend_idhas_many :r_friends, class_name: "Friendship",foreign_key: :answer_friend_idhas_many :answer_friends , class_name:"User" ,through: :a_friendshas_many :request_friends,class_name: "User" ,through: :r_friendsend</code></pre><h3>联结表</h3><pre><code class="language-Ruby ">class Friendship &lt; ApplicationRecordbelongs_to :request_friend,class_name: "User"belongs_to :answer_friend,class_name: "User"end</code></pre><h3>迁移</h3><pre><code class="language-Ruby ">class CreateFriendships &lt; ActiveRecord::Migration[5.2]def changecreate_table :friendships do |t|t.integer :request_friend_idt.integer :answer_friend_idt.timestampsendendend</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rails,多对多,自联结,好友关系 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
