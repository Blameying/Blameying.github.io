<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法学习-寻找最大子数组和</title>
      <link href="/2019/01/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
      <url>/2019/01/30/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p>通过对算法导论的再次学习，重新温习了一些比较经典的算法问题。今天看的是寻找给定数组的最大连续子数组和，问题是这样的：在给出的一个数组中，找出相加和最大的连续子数组，例如在数组<em>A={-1,2,3,4,-3,1}</em>中，最大连续子数组为<em>{2,3,4}</em>。<br>脱离开实际问题的算法题目是比较无趣的，因为算法的发明是前辈们为了解决某些实际问题而思考而出的。《算法导论》中给出了一个有趣的例子，该例是给了17天的单支股票的每日结算价格，让求解出在哪一日买入，在哪一日卖出，我们能获得最大的收益。数据如下图：<br><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBGQT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--868f0a4e3a92971bed26c486db4e1c3686e03ef2/%E6%A0%87%E9%A2%98.png" alt=""></p><p>这是原始的结算数据，对其进行一下处理：将每一日的结算价格与前一日做差，这样数据就会变成该日的变化情况，比如图上数据处理后为</p><p><em>[0,13,-3,-25,20,-3,-16……………………]</em></p><p>得到的数组进行寻找最大子数组和，也就是等同于寻找最大收益，最大子数组的起点下标就是应该买入的日子，终点下标就是应该卖出的日子。</p><p>有以下三种方法计算：</p><ul><li>穷举</li><li>分治</li><li>动态规划</li></ul><h3 id="穷举"><a href="#穷举" class="headerlink" title="穷举"></a>穷举</h3><p>穷举的是把所有可能的子数组都寻找一遍，进行比较，此处不把子数组当成整体来考虑，而是考虑起点和终点的所有可能，并且起点一定小于或等于终点，可能的组合如图：<br><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBGUT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--7b0968ef35cead7e4f6bdc8d0c8668c1cf8a1b99/qiongju.png" alt="穷举"></p><p>计算[a,b]可以使用[a,a]的结果，因此每种情况只计算一次加法即可，共需要计算n+n-1+n-2+……+1次，即：$\frac{n(n+1)}{2}$<br>代码比较简单，就是简单的遍历计算即可</p><pre><code class="lang-C++">struct MaxSeq{    unsigned int start;    unsigned int end;    long  sum;};private:        int* sequence;        size_t size;public:        MaxSeq bruteForce() const{            MaxSeq result={0,0,this-&gt;sequence[0]};            for(unsigned int i=0;i&lt;(unsigned int)(this-&gt;size);i++){                long temp_in=0;                for(unsigned int j=i;j&lt;(unsigned int)(this-&gt;size);j++){                    temp_in+=sequence[j];                    if(temp_in&gt;result.sum){                        result.start=i;                        result.end=j;                        result.sum=temp_in;                    }                }            }            return result;        };</code></pre><h3 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h3><p>分治思想是把大的问题同时拆分成很多小的问题，再把小问题求得的解进行合并计算从而获得大问题的解。<br>用分治算法来求解最大子数组和的算法是<br>求解数组最大子数组和</p><ol><li>如果数组长度大于1,将数组拆成两半，跳转到2，否则，返回唯一元素</li><li>对左数组求解数组最大子数组和，对右数组求解数组最大子数组和，求解跨越两个数组的最大子数组,到3</li><li>返回2中三个求解的最大结果</li></ol><p>很明显这是一个递归过程，拆分后的最大子数组可能在三个位置</p><ol><li>在左子数组</li><li>在右子数组</li><li>部分在左子数组，部分在右子数组</li></ol><p>示意图如下：<br><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBGZz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--d20dbb3239a1b0d851ff396376d8e19b6a1c83b0/guocheng.png" alt="过程图"></p><p>想起了手写数字识别，见谅：）<br>黑色箭头为拆分过程，红色为向上汇总时的选取操作，红色下标的为当前局部的最大子数组。<br>代码如下：</p><pre><code class="lang-C++">        MaxSeq DivideConquerParams(int* array,unsigned int start,unsigned int end) const{            MaxSeq result={start,start,array[start]};            if(start==end){                return result;            }else{                unsigned int middle = (end+start)/2;                MaxSeq left_result = DivideConquerParams(array,start,middle);                MaxSeq right_result = DivideConquerParams(array,middle+1,end);                MaxSeq between_result = findMaxSequenceBetweenTwoSubs(array,start,end,middle);                if(left_result.sum&gt;right_result.sum &amp;&amp; left_result.sum&gt;between_result.sum){                    return left_result;                }                if(right_result.sum&gt;left_result.sum &amp;&amp; right_result.sum&gt;between_result.sum){                    return right_result;                }                return between_result;            }        };        //求解跨越两个子数组的最大子数组        MaxSeq findMaxSequenceBetweenTwoSubs(int* array,unsigned int start,unsigned int end,unsigned int middle) const{            MaxSeq result={middle,middle,array[middle]};            long temp=0;            for(int i=middle;i&gt;=(int)start;i--){                temp+=array[i];                if(temp&gt;result.sum){                    result.start=i;                    result.sum=temp;                }            }            temp=result.sum;            for(unsigned int i=middle+1;i&lt;=end;i++){                temp+=array[i];                if(temp&gt;result.sum){                    result.end=i;                    result.sum=temp;                }            }            return result;        };</code></pre><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是解决这个问题速度最快的算法，时间复杂度是线性时间的。</p><blockquote><p>维基百科：<br>动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。</p><p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。</p><p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</p></blockquote><p>动态规划的关键在于重叠子问题和最优子结构，换言之局部最优和全局最优存在关系，可以通过局部最优减少得到全局最优的计算时间。<br>对于一个长度为N的数组A，已知<em>A[1，i]（1&lt;i&lt;n）</em>的最大子数组，则<em>A[1,i+1]</em>的最大子数组为<em>A[1,i]</em>的最大子数组或者<em>A[j,i+1]（1&lt;j&lt;i+1）</em></p><p>随着从前往后开始遍历数组，对所经过的数组进行求和，一旦和小于0则把之前的抛掉，重新设置当前点为起点，之所以把之前的全部抛掉而不是抛掉前半部分是因为，和小于0代表有负数元素，且负数元素的比重超过了正数，若负数元素主要分布在前半段，则根据规则，早就小于0了，绝对等不到现在，所以负数元素主要分布在后半段或均匀分布，所以只能全部抛掉。</p><p>动态规划的代码是最短的。</p><pre><code class="lang-C++">    MaxSeq dynamicProgram() const{            MaxSeq result={0,0,this-&gt;sequence[0]};            long temp=0,start = 0;            for(unsigned int i=1;i&lt;this-&gt;size;i++){                temp+=this-&gt;sequence[i];                if(temp&gt;result.sum){                    result.sum=temp;                    result.start=start;                    result.end=i;                }                if(temp&lt;0){                    temp=0;                    start=i+1;                }            }            return result;        };</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-观察者模式</title>
      <link href="/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>设计模式理解到什么地步才叫理解呢，我阅历还浅，讲道理也是讲想象中的道理，难免中气不足。我觉得设计模式并不难，当一件事很复杂的时候，是很难看出到底是用哪种设计模式的，因为他可能什么模式都有，严格定义的话，又什么设计模式都不是,可能需要划分成很多小部分。就我而言，设计模式给了我一些思考的方向，甚至无形中改变了思考的模式，这就是比较大的收获。所有设计模式都必须学么？不是，有的设计模式是你自己在思考的过程中无形中就能用出来的，哪怕你不知道他是什么，这种本领比你能念出它的名字更重要。这些模式都很朴实，平易近人。</p><p>在日常生活中存在很多这样的场合，信息源向很多信息接收点传递信息，就像千家万户的电视，对于一个电视台，发布源其实只有一个。这个还不太明显，比如大家在聊天群的群聊，一旦有新的消息，每个人都会及时收到通知。大家都能想到，这应该是一个遍历的过程。观察者模式就适用于这种场合。</p><p>一个信息发布源，应该有以下功能：</p><ul><li>添加观察者</li><li>删除观察者</li><li>通知所有观察者信息</li></ul><p>所以把被观察的对象做成如下这样</p><pre><code class="lang-java">public interface Observable {    public Boolean attachObserver(MyObserver observer);    public Boolean removeObserver(MyObserver observer);    public void notifyAllObservers();}</code></pre><p>相应的对于观察者来说，要提供一个统一的方法来获取信息。</p><pre><code class="lang-java">public interface MyObserver {    public void update(String info);}</code></pre><p>假设有一家报社，要为用户提供新闻订阅业务</p><pre><code class="lang-java">//用户public class Order implements MyObserver{    private String name;    public Order(String name){        this.name = name;    }    public void update(String info) {        System.out.println(this.name+&quot;: &quot;+info);    }}//报社public class NewspaperOffice implements Observable{    private ArrayList&lt;MyObserver&gt; observers;    private String newspaper = &quot;&quot;;    public NewspaperOffice(){        observers = new ArrayList&lt;MyObserver&gt;();    }    public void attachObserver(MyObserver observer) {        observers.add(observer);    }    public void removeObserver(MyObserver observer) {        observers.remove(observer);    }    public void notifyAllObservers() {        for (MyObserver observer:observers){            observer.update(this.newspaper);        }    }    public void setNewspaper(String newspaper){        this.newspaper = newspaper;    }}</code></pre><p>这样，当我们有新用户需要添加的时候，</p><pre><code class="lang-java">public class Client {    public static void main(String[] args) {        MyObserver observer1 = new Order(&quot;observer1&quot;);        MyObserver observer2 = new Order(&quot;observer2&quot;);        NewspaperOffice newspaperOffice = new NewspaperOffice();        newspaperOffice.attachObserver(observer1);        newspaperOffice.attachObserver(observer2);        newspaperOffice.setNewspaper(&quot;This is a new message&quot;);        newspaperOffice.notifyAllObservers();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,观察者 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-策略模式</title>
      <link href="/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>策略模式是一种选择，给一个灵活的接口，然后去选择，只要是这个接口下的子类，我们都能去选，在不同的场合，选择会不同，这就是策略。客户端或者是决策者，是依赖于这个接口的，而不依赖具体的实现。</p><p>如排序算法是有很多种的，所有排序算法都可以实现排序这个接口。</p><pre><code class="lang-java">public interface SortInterface {    public void sort(int[] data);}</code></pre><p>然后我们创建实现这个接口的具体类</p><pre><code class="lang-java">public class BubbleSort implements SortInterface{    public void sort(int[] data) {        //假装排序        //TO-DO 冒泡排序的逻辑    }}public class QuickSort implements SortInterface{    public void sort(int[] data) {        //假装排序        //TO-DO 快速排序的逻辑    }}</code></pre><p>可供选择的项已经做好了。<br>那么我们要做关于策略的选择了</p><pre><code class="lang-java">public class Client {    SortInterface sortTool = null;    public Client(SortInterface sortTool){        this.sortTool = sortTool;    }    public void doSort(int[] data){        if(this.sortTool!=null){            this.sortTool.sort(data);        }    }}</code></pre><p>策略模式让我凡是思考问题都一定要考虑接口结构。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,策略模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-桥接模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>桥接模式是虚拟了一座“桥”，只不过这座”桥”的两端是抽象和实体。在维基百科用的是抽象的图形和画图的关系，我尝试找一中新的例子来两相比较促进理解。</p><p>鸟是会飞的，不同的鸟有不同的飞行姿态，当然有的不是鸟的也可以飞。所以建立一个飞行的接口</p><pre><code class="lang-java">public interface Flyable {    public void fly();}</code></pre><p>实现两种具体的动作</p><pre><code class="lang-java">public class FastFly implements Flyable{    public void fly() {        System.out.println(&quot;Fastly Fly&quot;);    }}public class SlowFly implements Flyable{    public void fly() {        System.out.println(&quot;Slowly Fly&quot;);    }}</code></pre><p>这是具体的那一部分，实现了具体的行为。</p><p>那在这个故事里谁是抽象的那一部分，可以是鸟，也可以是“能力”<br>这里我选择鸟。</p><pre><code class="lang-java">public interface Bird{    public void fly();}</code></pre><p>鸟拥有这样一种能力，而这种能力的具体实现我们已经分离出去了，接下来搭一个桥梁将其连接起来。</p><p>创建麻雀种</p><pre><code class="lang-java">public class Sparrow implements Bird{    private Flyable flyable = new FastFly();    public void fly() {        flyable.fly();    }}</code></pre><p>现在来看一下这个模式有啥用，桥接模式最大(个人理解)的好处是使得桥的两端可以单独变化而互不影响，不管比如具体端，飞行的具体方式不管如何实现，鸟只要调用fly就行了，这个是永远不变的，而鸟类的变化对飞行的具体方式也没影响，都是鸟类调用飞行。</p><p>感觉桥接模式无处不在。</p><p>一个简单的例子，以后有新的感受再来填坑。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,桥接模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-适配器模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>适配器并不是一个软件开发的专用术语，而是应用于生活的方方面面，一般用来提供不同接口之间的转接。例如下图：</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBEdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--189d423e8e56b7cd49a3b10646812576aed66af2/1348019735-2591968284.jpg" alt="水管适配"></p><p>这个可以使得不同粗细的水管接在一起。</p><p>又比如我们用的网线有一种接口，那么光纤解码器也是一种适配器。不变的是其中流动的数据，就像上图中不变的是流动的水。</p><p>在代码中，有时需要使用一些外部的资源，或者对已有的资源定义一种新的接口都可以应用适配器模式。我们不妨先定义一种接口</p><pre><code class="lang-java">public interface WeatherGet {        //通过城市名获得城市天气数据    public String getTheCityWeather(String city);}</code></pre><p>而原有的代码接口可能是这样的:</p><pre><code class="lang-java">public class CityWeather {    public String getWeather(int id){        String weather = &quot;&quot;;        //假设1是北京的id        switch (id){            case 1:                weather = &quot;北京： 晴&quot;;                break;            default:                weather=&quot;&quot;;        }        return weather;    }}</code></pre><p>看到这里我们不能重写一个CityWeather,因为那样会耗时耗力，这里有现成的，实在不想写，并且获取天气的代码可能是私有的</p><p>要不把接口改了? 可是我们不止从一个天气发布源获取天气数据，改了接口，以前的其他代码就不能用了。</p><p>这就是适配器的应用场合了，</p><pre><code class="lang-java">public class AdaptorForCityWeather extends CityWeather implements WeatherGet {    public String getTheCityWeather(String city) {        int weather_id = 0;        switch (city) {            case &quot;Beijing&quot;:                weather_id = 1;                break;            default:                    break;        }        if(weather_id!=0) {            return getWeather(weather_id);        }else {            return &quot;&quot;;        }    }}</code></pre><p>这样我们完全可以这么用了:</p><pre><code class="lang-java">WeatherGet weatherGet = new AdaptorForCityWeather();System.out.println(weatherGet.getTheCityWeather(&quot;Beijing&quot;));</code></pre><p>方法调用起来和其他的没什么两样，完全可以放进列表中循环调用。只要实现我们用的接口，我们就不需要关注其他的差异。</p><p>如果我们比较贪心，想要一个接口实现多个接口不同的已有类的功能怎么办，可以看到我们上面用的是继承，很多语言是不支持多继承的，比如java</p><p>这样可以用关联的方式，通过生成旧类的变量来实现那么上面的接口类可以略作修改</p><pre><code class="lang-java">public class AdaptorForCityWeather implements WeatherGet {    public String getTheCityWeather(String city) {                CityWeather cityWeather = new CityWeather();        int weather_id = 0;        switch (city) {            case &quot;Beijing&quot;:                weather_id = 1;                break;            default:                                                                          break;                                                        }        if(weather_id!=0) {                                                           return cityWeather.getWeather(weather_id);        }else {            return &quot;&quot;;                                                            }                                                                     }}</code></pre><p>用的例子是比较简单的适配器，我觉得以后遇到复杂的顺着这种思路应该能够理的清。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式，适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-抽象工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>走过了简单工厂模式和工厂模式，我来了解一下抽象工厂模式，现在已经知道“工厂”二字的含义了，就是帮别人建造对象，想想JDBC(数据库连接库)中用到的getConnection之类的方法，这就是工厂模式的应用啊。但是简单工厂模式和工厂模式都存在那个添加和修改必须更改以前代码的问题，这是不符合开闭原则的，也不是我们非要鸡蛋里挑骨头，而是在大体量的项目中，能不重新编译就不重新编译，能不引入更多变数就不引入更多变数，更希望的是像vscode编辑器的插件一样，这样的扩展性让人很舒服，开发者不需要修改官方的源码，每个人都可以互相不影响的开发插件。</p><p>那么如何令工厂模式符合开闭原则呢，能不能我从配置文件中动态获取类的名称然后自动的选择调用哪个工厂呢，当然可以。</p><pre><code class="lang-java">MapFactorys myMap = Class.forName(&quot;MapAFactory&quot;).newInstance();</code></pre><p>当提供的参数变成字符串的话，我们的可操作性就变大了。其实用Ruby这样的元编程语言能把工厂模式做的更好。</p><p>接下来看一下抽象工厂模式<br>工厂模式和抽象工厂模式最大的区别就是</p><ul><li>工程模式面向单个层面的产品</li><li>抽象工厂模式面向多个层面的产品</li></ul><p>一个游戏肯定不止有地图，这个地图上得有对应的野怪，得有对应的据点吧，得有杂七杂八的其他东西，我们前面已经这么较真设计了，肯定忍受不了这么多东西都把责任扔在地图身上。<br>一个工厂可不可以在建立地图的时候，把这张图对应的各个品种的野怪和各个类型的据点(建筑物)给搞定呢。</p><p>在原来的代码的基础上添加Monster相关</p><pre><code class="lang-java">//Monster 接口public interface Monster {    public void say();}public class MonsterA implements Monster{    public void say() {        System.out.println(&quot;I am Monster A&quot;);    }}public class MonsterB implements Monster {    public void say() {        System.out.println(&quot;I am Monster B&quot;);    }}</code></pre><p>修改一下工厂相关</p><pre><code class="lang-java">public interface Factorys {    public static Factorys getFactory(String select){        Factorys factorys = null;        switch (select){            case &quot;FactoryA&quot;:                factorys = new FactoryA();                break;            case &quot;FactoryB&quot;:                factorys = new FactoryB();                break;            default:                factorys =null;        }        return factorys;    }    public Monster getMonster();    public GameMap getGameMap();}public class FactoryA implements Factorys {    public Monster getMonster() {        return new MonsterA();    }    public GameMap getGameMap() {        return new MapA();    }}public class FactoryB implements Factorys{    public Monster getMonster() {        return new MonsterB();    }    public GameMap getGameMap() {        return new MapB();    }}</code></pre><p>其实从这里就可以看出，抽象工厂模式并没有更优秀，只是和工厂模式适合的场合不一样，这里的FactoryA 和 FactoryB 其实是不同的生产组合。</p><p>客户端代码</p><pre><code>import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;        Monster monster = null;        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            Factorys f = Factorys.getFactory(selected);            monster = f.getMonster();            map = f.getGameMap();        }        if(map!=null &amp;&amp; monster!=null) {            map.draw();            monster.say();        }    }}</code></pre><p>如果我们添加一个新品种的怪物或者新的地图又或者新的一种组合，都可以通过添加该产品接口下的类和新的工厂类，如果配合一开始所说的Class.forname方法，可以满足开闭原则，但要是我要加入据点这一新的种类呢，亦或者说这一新的层次呢，那我所有的已有的工厂都需要新加一个方法，getXXXX，所以是不满足开闭原则的。真正体会到了设计模式只是提供一种解决问题的思路，没有什么所谓的标准定式，需要根据实际的情况选择和改变。所以真正有意义的是前人这种思考的方式。<br>看后面能不能用ruby实现一个更优美的工厂方法吧。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>上一篇遗漏了一些问题，工厂模式特别适合那种创建比较复杂的对象，这样将创建的任务交给其他部分，使得客户端代码更简介，调用更方便。后来者少写代码，减少代码的重复，提高复用性。<br>简单工厂模式比工厂模式简单，但工厂模式是简单工厂模式的进化么？我觉得不是，因为该少的东西一点都没少，那工厂模式多了什么？</p><p>工厂模式的思路大概是这样的，还用上一篇游戏地图的例子，每一个地图所需要的参数和定制有可能是不一样的，要不要为每一个地图单独适配一个自己专门的工厂呢，我们把复杂的创建逻辑放在属于这个地图的工厂里，那这样，彼此的工厂不会混乱，地图本身的类也更符合一个模型的结构。这就是工厂模式，为每一个地图创建一个单独的工厂。</p><p>那么依据面向接口编程的原则，给出地图的代码</p><pre><code class="lang-java">//定义统一的调用接口public interface GameMap{    public void draw();}//普通地图类 A 和 Bpublic class MapA implements GameMap{    public void draw(){        System.out.println(&quot;This is MapA&quot;);            }}public class MapB implements GameMap{    public void draw(){        System.out.println(&quot;This is MapB&quot;);    }}</code></pre><p>接下来是工厂类的结构</p><pre><code class="lang-java">//工厂的接口public interface MapFactorys {    public static MapFactorys createFactory(String selected){        MapFactorys mapFactorys = null;        switch (selected){            case &quot;MapAFactory&quot;:                mapFactorys = new MapAFactory();                break;            case &quot;MapBFactory&quot;:                mapFactorys = new MapBFactory();                break;                default:                    mapFactorys = null;        }        return mapFactorys;    }    public GameMap createMap();}//具体的工厂public class MapAFactory implements MapFactorys{    public GameMap createMap() {        return new MapA();    }}public class MapBFactory implements MapFactorys{    public GameMap createMap() {        return new MapB();    }}</code></pre><p>确实，单一工厂只生产单一产品，在这里就是只生产单一的地图。<br>客户端的逻辑基本不需要变。</p><pre><code class="lang-java">import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            map = MapFactorys.createFactory(selected).createMap();        }        if(map!=null) map.draw();    }}</code></pre><p>这样改的好处目前是看不来的，这是因为没看到我们用工厂生产一个东西有多么复杂，试想如果构建一个东西需要很多先决条件呢，也就是必须分为几步的话，不同的地图，这几步还不一样的话，工厂模式的好处就会体现出来，成功的分离了产品和产品之间的变化点。</p><p>但是工厂模式仍然有比较大的麻烦，相信大家也发现了，在工厂接口中的静态方法，免不了还是一堆的条件判断。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-简单工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>公认的有理之言已经被传递的铺天盖地，不多我一个传播者，所以我说一下自己的思考，还希望看到的人对有错存疑之言不吝赐教。</p><p>设计模式是在实践中总结出的做出更好的软件的一些方法，什么是更好的软件，就我看来是在当前基础上不管是修改还是添加，都能给开发者省点力气的软件。能做到这点就足以说明这个软件的结构很好，并且在开发的时候不仅考虑了眼下的事情，还考虑了将来的事。应用设计模式的代码不一定性能更优，不一定代码更少，这取决于代码的体量和计划中的生存周期。</p><p>我们玩游戏一般都会有各种各样的地图，我们可以灵活的在各种地图之间切换,那么一般直觉的设计是下面这样的:</p><pre><code class="lang-java">public class Client{    //客户端类    //在这里接受用户输入    //判断输入是哪种地图，然后生成指定的地图。    /*        switch(选择)        {            case XX :          ............        }    */}</code></pre><p>相信上面的简明代码大家都能看懂，这个代码一看上去是没有问题的，不妨多想一步，我每次增加或者修改地图，都需要重新修改客户端代码，一是容易污染客户端代码，随着地图的增加，开发者对客户端代码编辑次数增加，难免会误动其他代码，或者多个人同时需要修改不同的东西，而这些东西都在客户端，同步问题，版本控制问题就会都暴露出来，由此可见，这不是客户端应该干的事，我们应该把选择地图这件事分离出来。</p><p>容易想到，我们建立一个单独的类，客户端只负责给它想要的类的名字，产生地图的细节和根据名字做出判断都交给这个类来做，那事情是不是就解决了? 客户端中获知这些类叫什么，有多少地图，这都是非代码信息，完全可以用配置文件或者用户输入来解决，也就是说我们让客户端真正分离出去了，再也不用修改客户端。代码示例如下</p><pre><code class="lang-java">//定义统一的调用接口public interface GameMap{    public void draw();}//普通地图类 A 和 Bpublic class MapA implements GameMap{    public void draw(){        System.out.println(&quot;This is MapA&quot;);            }}public class MapB implements GameMap{    public void draw(){        System.out.println(&quot;This is MapB&quot;);    }}//负责处理地图选择的逻辑public class GameMapFactory{    private static GameMap map;    public static GameMap getMap(String selected){        switch (selected){            case &quot;MapA&quot;:                map = new MapA();                break;            case &quot;MapB&quot;:                map = new MapB();                break;            default:                map = null;                break;        }        return map;    }}import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;                //地图名可以从输入得到，但更合适的是从配置文件得到。        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            map = GameMapFactory.getMap(selected);        }        if(map!=null) map.draw();    }}</code></pre><p>这样我们每次扩展或者修改的时候只需要单独修改 GameMapFactory 的源码就可以。 然而等到地图多了，这里面的代码仍然会不太优美。所以人们又想出了工厂模式。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux 安装.net core</title>
      <link href="/2018/10/16/Archlinux-%E5%AE%89%E8%A3%85-net-core/"/>
      <url>/2018/10/16/Archlinux-%E5%AE%89%E8%A3%85-net-core/</url>
      
        <content type="html"><![CDATA[<p>从Arch源安装:</p><pre><code class="lang-bash">sudo pacman -S dotnet-sdk</code></pre><p>这个时候已经安装了.net core<br>找一个心仪的存放工程的目录</p><pre><code class="lang-bash">dotnet new mvc --auth Individual -o YouProjectName</code></pre><p>这里的几个参数解释一下，new 是创建新工程，类似于django，rails创建工程时的模式。<br>mvc是指建立web工程，—auth是认证方式，这里几个可选的参数，具体说明参见<a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21" target="_blank" rel="noopener">MSDN</a><br>一般教程讲到这就是运行工程了</p><pre><code class="lang-bash">cd YouProjectNamedotnet run</code></pre><p>但是在我这边出了些问题，提示如下：</p><blockquote><p>System.InvalidOperationException: Unable to configure HTTPS endpoint. No server certificate was specified, and the default developer certificate could not be found.To generate a developer certificate run ‘dotnet dev-certs https’. To trust the certificate (Windows and macOS only) run ‘dotnet dev-certs https —trust’. For more information on configuring HTTPS see <a href="https://go.microsoft.com/fwlink/?linkid=848054" target="_blank" rel="noopener">https://go.microsoft.com/fwlink/?linkid=848054</a>.</p></blockquote><p>解决方案如下：</p><pre><code class="lang-bash">dotnet tool install --global dotnet-dev-certs</code></pre><p>然后执行</p><pre><code class="lang-bash">dotnet dev-certs https</code></pre><p>如果提示错误：</p><blockquote><p>A fatal error occurred, the required library libhostfxr.so</p></blockquote><p>接下来设置环境变量</p><pre><code class="lang-bash">export DOTNET_ROOT=/opt/dotnet</code></pre><p>重新执行出错的那句。</p><p>可以把设置环境变量的语句放入<br>~/.bashrc 或者 ~/.xprofile文件，这样就不需要每次手动加载了。</p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux,dotnet core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux安装Boost库</title>
      <link href="/2018/10/16/Archlinux%E5%AE%89%E8%A3%85Boost/"/>
      <url>/2018/10/16/Archlinux%E5%AE%89%E8%A3%85Boost/</url>
      
        <content type="html"><![CDATA[<p>Archlinux 软件源中有boost 不需要自己编译安装。</p><pre><code class="lang-bash">sudo pacman -S boost</code></pre><p>刷新一下当前环境</p><pre><code>ldconfig</code></pre><p>新建立一个代码文件，测试一下boost库是否安装成功了。</p><pre><code class="lang-cpp">#include &lt;boost/timer.hpp&gt; //boost库统一用hpp#include &lt;iostream&gt;using namespace boost;using namespace std;int main(){    timer t;    cout &lt;&lt; &quot;max timespan:&quot; &lt;&lt; t.elapsed_max() / 3600 &lt;&lt; &quot;h&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;min timespan:&quot; &lt;&lt; t.elapsed_min() &lt;&lt; &quot;s&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;now time elapsed:&quot; &lt;&lt; t.elapsed() &lt;&lt; &quot;s&quot; &lt;&lt; endl;}</code></pre><p>编译的时候按照gnu的编译规矩要手动指定库文件</p><pre><code class="lang-bash">g++ source_filename.cpp -lboost_timer -o execute_filename</code></pre><p>这里用-lboost_timer是因为我们用到了timer头文件。用其他库要改成-lboost_xxx</p>]]></content>
      
      
      <categories>
          
          <category> Boost </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boost,Archlinux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 Vue.js 时的心理活动</title>
      <link href="/2018/10/03/%E5%88%9D%E8%AF%86-Vue-js-%E6%97%B6%E7%9A%84%E5%BF%83%E7%90%86%E6%B4%BB%E5%8A%A8/"/>
      <url>/2018/10/03/%E5%88%9D%E8%AF%86-Vue-js-%E6%97%B6%E7%9A%84%E5%BF%83%E7%90%86%E6%B4%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>在大学参与的小项目或者作业中总是当那个写后端的角色，前后林林总总用了各式框架和各种语言，包括java, python-flask, ruby on rails,总觉得视觉设计很炫酷，视觉的美感比较直接和强烈，也更容易被人共鸣。你想一个普通人看到你写的代码是不可能说：哇，这真是太美了。这点真的很难，很多写代码很多年的人也不会有这种美感。所以说这么多，总而言之，我想学一些前端，不是为了工作，而是为了自己在自娱自乐的时候用更多发挥的空间。</p><p>以前也看过javascript,html,css的相关知识，但你要说实战的时候能信手拈来还差的远。但这个东西吧，思想上很难接触，html，css是纯标记的语言，让人感觉死板和本身的工具性特别浓厚。排版啊，样式啊，是这些东西，而不是传统后端的逻辑。我不太想学javascript，可能是我从它的形式里很难找到美感吧，个人感受。</p><p>在合作完成作业的时候，做前端的同学用到了vue.js，我虽然早有耳闻，但没有这种亲身接触的印象深刻。首先，我觉得这个框架设计的很清晰，解决了很多人们不需要关心的问题。于是我去<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue官网</a>看完了大半的文档。但是，却难以有整体的把握，后来在youtube上看了个60分钟介绍的短片，又自己做了一个toy project，这才感觉可以上手了。</p><p>那么说一下当下的理解。</p><p>关于v-if v-for之类的在理解上没有什么问题。关键是模板模块和路由。vue为了提高代码的重复利用，允许用户把代码分成一个个模块，那么在构建一个新的网页的时候如果有需要的组件可以直接拿过来用。一个网站的不同网页为了保持样式的统一肯定有很多部分需要在不同的网页中重复利用，这样可以直接在父元素中包含这个组件。组件之间允许嵌套。组件之间可以通过props传递变量。每一个组件就是一个小的页面，在这个组件的vue文件中可以直接定义自己js和css。使得整个工程的结构清晰。一张网页就可以看成一张画纸，组件就是拼图，就看怎么摆放了。<br><br><br><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBDQT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--9d8daffc97fba3c799b11d7033c19cd94ac9d456/timg%20\(1\" alt="">.jpeg)<br><br><br>做的一个样例，列表内容临时去<a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a>摘的，应该看不清吧。</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBDUT09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--bab84b20863c01a09f1206f9b24901c481c4adcf/vu1.png" alt=""></p><pre><code class="language-javascript line-numbers">&lt;template&gt;    &lt;div class="HomePage"&gt;        &lt;div class="person"&gt;            &lt;img class="headico" v-bind:src="user.headico"&gt;            &lt;h3 class="username"&gt;{{user.username}}&lt;/h3&gt;            &lt;p&gt;{{user.info}}&lt;/p&gt;        &lt;/div&gt;        &lt;articlelistitem&gt;&lt;/articlelistitem&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ArticleListItem from './ArticleListItem.vue'export default {  name: 'HomePage',  data () {    return {      user: {        headico: 'http://img4.duitang.com/uploads/item/201411/09/20141109142633_ncKBY.thumb.700_0.jpeg',        username: 'Xblame',        info: '一个简单的读书人'      }    }  },  components: {    'articlelistitem': ArticleListItem  }}&lt;/script&gt;&lt;style scoped&gt;.headico {    width: 100px;    height: 100px;    border-radius: 50px;}&lt;/style&gt;</code></pre><p>这其实是一个HomePage的组件，就是图上的用户头像，姓名，信息那一块。下面的列表是一个单独的模块ArticleListItem，HomePage中引用了它。</p><p>一个网站的路由是比较核心的功能，路由就是通向一个网页的链接，比如对于一个母版的网页，中间包含了一个组件，那么针对不同的链接可以通过路由更换其中的组件，首先vue有一个总的路由，这个路由可以通向各个大的组件，但一个复杂的网页中，大的组件势必包含一些小的组件，这个时候需要嵌套路由。举个例子：</p><p><strong>访问一个网站的域名，也就是访问其根目录，首先route根据你定义的根目录渲染那个模块，如果这个模块还包含一个&lt;router-view/&gt;的路由入口,比如你想让ArticleListItem插入在这，你就需要访问/articlelistitem,即在父组件的路由路径后加上自己的路由路径。</strong></p><p>不建议嵌套很多层，根据在其他领域得到的经验。层次结构超过一定限度会极大增加复杂度，尽可能转化成平面结构。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MRB主引导记录</title>
      <link href="/2018/09/25/MRB%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/09/25/MRB%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>这几天因为一直在看操作系统和文件系统相关的书，了解到了MBR的作用的结构，记录一下。<br>MBR(master boot record)主引导记录位于存储设备的绝对零扇区，这里的绝对零扇区是指物理上的起点。MBR整个结构共占用<strong>512</strong>Byte。接下来用一个C语言结构体来表示一下</p><pre><code class="language-c line-numbers">struct MBR{    uint8 PartCode[446];    //MBR引导程序    struct Partition DPT[4];    //四个分区信息    uint8 BootSectSig0;     //55    uint8 BootSectSig1;     //AA};/* 55 AA 在最后两个字节，小端字序，真实值为AA55,代表正常扇区结束。*/struct Partition{    uint8 Active;   //引导指示符，指明次分区是否是活动分区，取值为0x80，说明可以引导操作系统，通常取0    uint8 StartHead;    //分区的开始扇头    uint16 StartCylSect;    //开始柱面和扇区，前6位为开始扇区，后10位为开始柱面    uint8 PartType;     //分区类型    uint8 EndHead;  //分区的结束头    uint16 EndCylSect;  //结束柱面与扇区，前6位为结束扇区，后10位为结束柱面    uint32 StartLBA;    //分区的第一个扇区地址    uint32 TotalSector; //分区的总扇区数};</code></pre><blockquote>  该处出自 《嵌入式FAT32文件系统设计与实现》于振南 编著</blockquote><p>DPT(Disk Partition Table ) 磁盘分区表</p><p>开始的446个字节的是一段引导代码。简单来说是一段 程序，在计算机上电以后，<a href="https://baike.baidu.com/item/bios" target="_blank" rel="noopener">BIOS</a>(Base Input Output System 基本输入输出系统)会自动读取MBR的前446个字节，然后执行这段代码，这段代码会对mbr区后面的分区信息的代码进行读取分析，找到分区信息，根据分区信息找到需要引导的操作系统的程序，进而启动操作系统。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Archlinux 声音配置</title>
      <link href="/2018/09/13/Archlinux-%E5%A3%B0%E9%9F%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/13/Archlinux-%E5%A3%B0%E9%9F%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Archlinux 通常使用alsa管理声音，需要安装alsa-utils包<br>安装完是默认静音的。需要执行</p><pre><code class="language-shell line-numbers">amixer sset Master unmute</code></pre><p>如果提示：amixer: Unable to find simple control ‘Master’,0<br>则表示不能找到声卡设备需要继续配置<br>执行命令获取声卡的声卡ID和设备ID</p><pre><code class="language-shell line-numbers">aplay -l</code></pre><p>结果如下</p><pre><code class="language-shell line-numbers">**** List of PLAYBACK Hardware Devices ****card 0: HDMI [HDA Intel HDMI], device 3: HDMI 0 [HDMI 0]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 7: HDMI 1 [HDMI 1]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 8: HDMI 2 [HDMI 2]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 9: HDMI 3 [HDMI 3]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 10: HDMI 4 [HDMI 4]  Subdevices: 1/1  Subdevice #0: subdevice #0card 1: PCH [HDA Intel PCH], device 0: ALC282 Analog [ALC282 Analog]  Subdevices: 0/1  Subdevice #0: subdevice #0</code></pre><p>把下列配置添加到系统级别的 /etc/asound.conf 或用户级别的 ~/.asoundrc 文件。如果文件不存在，可以手动创建。其中的各个ID，根据实际情况调整：</p><pre><code class="language-shell line-numbers">defaults.pcm.card 1   #根据上面输出的信息，ALC282是我的设备，选择card=1defaults.pcm.device 0 #device 为0defaults.ctl.card 1  #决定哪个声卡能由alsamixer控制</code></pre><p>同时，对于i3wm,fluxbox之类的wm（窗口管理器），而不是DE(Desktop environment),往往需要自己设置音量快捷键<br>这里给出i3的例子（编辑~/.config/i3/config）文件</p><pre><code class="language-shell line-numbers">#设置静音bindsym XF86AudioMute exec "amixer -q sset Master,0 toggle"#设置音量调节bindsym XF86AudioRaiseVolume exec --no-startup-id  amixer -c 0 set Master 3%+bindsym XF86AudioLowerVolume exec --no-startup-id  amixer -c 0 set Master 3%-</code></pre>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alsamixer,Archlinux,声音 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grub 提示: Failed to connect to lvmetad……</title>
      <link href="/2018/09/13/grub-%E6%8F%90%E7%A4%BA-Failed-to-connect-to-lvmetad%E2%80%A6%E2%80%A6/"/>
      <url>/2018/09/13/grub-%E6%8F%90%E7%A4%BA-Failed-to-connect-to-lvmetad%E2%80%A6%E2%80%A6/</url>
      
        <content type="html"><![CDATA[<p>编辑 /etc/lvm/lvm.conf<br>找到 use_lvmetad = 1<br>将其修改为</p><pre><code class="language-bash line-numbers">use_lvmetad = 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rails-理解</title>
      <link href="/2018/09/11/Rails-%E7%90%86%E8%A7%A3/"/>
      <url>/2018/09/11/Rails-%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Rail 核心目录在于app下面的model,controller,view<br><br><br>是经典的MVC结构，以Model数据为中心，Model通过ActiveRecord模块与数据库连接，不需要自己在Model里定义变量和getter，setter之类的在java中常写的存取函数，只需要在db/migrate目录中定义同名数据库表，接下来便开始忽略与数据库相关的事，暂时将其透明化。controller负责定义一系列与数据相关的动作，组织数据，生成视图。即负责链接数据和视图。<br><br><br>route.rb 负责链接url和controller</p><p><img src="http://xblame.top:8080/rails/active_storage/blobs/eyJfcmFpbHMiOnsibWVzc2FnZSI6IkJBaHBFdz09IiwiZXhwIjpudWxsLCJwdXIiOiJibG9iX2lkIn19--76b16363b144860046c8c3790ae4e27a5b6ab37a/10-03-3.jpgrails%E7%90%86%E8%A7%A3.png" alt=""></p><p>view 中指定的视图应当与其在controller中对应的动作存在共享实例变量和几个全局变量，进行数据的交互。</p><p>controller 和 view 的对应关系，model和数据库的对应关系使用约定。一开始觉得体系庞大，难以掌控，我觉得不妨先观察，然后思考，不知所以然的照着教程写一遍不利用后面摆脱固定的模式限制进行自定义。不妨多些勇敢，多尝试，不用觉得与示范做法不一样，这样才能真正的使用。</p><hr><p>以下内容补充自 2019-1-30 11:53</p><p>rails 存在很多自己的DSL，包括各种不同的插件也实现了自己的DSL，使我有时会摸不着头脑，按照惯常的思维会去查阅大量资料试图理解他的工作原理，然后才知道该怎么去实现我想要的功能，说实话这个框架现在有些“重”，渐渐变得不快乐。实际上我还是在用C语言之类的强类型语言的思维试图掌控所有细节。也许在使用ruby和rails时学会放手，能更舒服一些，慢慢的用的多了自然而然就理解了。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rails </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 类中方法参数 self</title>
      <link href="/2018/09/06/python-%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-self/"/>
      <url>/2018/09/06/python-%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-self/</url>
      
        <content type="html"><![CDATA[<h3>内存</h3><p>Python 类在内存中的实现是类有自己的一个空间，存放类中的定义的变量和方法，在声明一个实例的时候，为该实例分配一块新的空间，但仍有引用指向类，这也是大部分面向对象的设计方法，对大家都有的东西只存在一份。当实例变量中的变量绑定新的值，或是方法覆写这些自己独有的东西存放在自己的空间里。当多个实例变量去访问同一个函数，这个函数如果没有被覆写应当是在类空间里的。那这个方法自然而然就需要区分是哪个实例调用的自己。在这里，python为了精确，需要手动声明这个需要传递的实例的引用。</p><h3>为什么是self?</h3><p>self其实是一种约定俗称的写法，因为传递实例变量引用的这个过程是自动的，python会自动把引用填入第一个参数，所以，python类的实例方法至少接受一个参数。python只接受第一个参数，而不管这个参数的名字，所以可用任何一个单词替换self，但self意义比较明显，所以大家习惯用self。</p><blockquote>  Often, the first argument of a method is called self. This is nothing more than a convention: the name self has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention  ----Python Document</blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> class,python,self </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rails 多对多 自联结 建立好友关系表</title>
      <link href="/2018/09/03/Rails-%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E8%87%AA%E8%81%94%E7%BB%93-%E5%BB%BA%E7%AB%8B%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E8%A1%A8-md/"/>
      <url>/2018/09/03/Rails-%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E8%87%AA%E8%81%94%E7%BB%93-%E5%BB%BA%E7%AB%8B%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E8%A1%A8-md/</url>
      
        <content type="html"><![CDATA[<h3>Model</h3><pre><code class="language-Ruby ">class User &lt; ApplicationRecordhas_many :a_friends, class_name: "Friendship",foreign_key: :request_friend_idhas_many :r_friends, class_name: "Friendship",foreign_key: :answer_friend_idhas_many :answer_friends , class_name:"User" ,through: :a_friendshas_many :request_friends,class_name: "User" ,through: :r_friendsend</code></pre><h3>联结表</h3><pre><code class="language-Ruby ">class Friendship &lt; ApplicationRecordbelongs_to :request_friend,class_name: "User"belongs_to :answer_friend,class_name: "User"end</code></pre><h3>迁移</h3><pre><code class="language-Ruby ">class CreateFriendships &lt; ActiveRecord::Migration[5.2]def changecreate_table :friendships do |t|t.integer :request_friend_idt.integer :answer_friend_idt.timestampsendendend</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rails,多对多,自联结,好友关系 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
