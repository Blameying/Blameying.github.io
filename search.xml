<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>设计模式-适配器模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>适配器并不是一个软件开发的专用术语，而是应用于生活的方方面面，一般用来提供不同接口之间的转接。例如下图：</p><p><img src="http://pbn2nc8d5.bkt.clouddn.com/Adaptor.jpg" alt="水管适配"><br>这个可以使得不同粗细的水管接在一起。</p><p>又比如我们用的网线有一种接口，那么光纤解码器也是一种适配器。不变的是其中流动的数据，就像上图中不变的是流动的水。</p><p>在代码中，有时需要使用一些外部的资源，或者对已有的资源定义一种新的接口都可以应用适配器模式。我们不妨先定义一种接口</p><pre><code class="java">public interface WeatherGet {        //通过城市名获得城市天气数据    public String getTheCityWeather(String city);}</code></pre><p>而原有的代码接口可能是这样的:</p><pre><code class="java">public class CityWeather {    public String getWeather(int id){        String weather = &quot;&quot;;        //假设1是北京的id        switch (id){            case 1:                weather = &quot;北京： 晴&quot;;                break;            default:                weather=&quot;&quot;;        }        return weather;    }}</code></pre><p>看到这里我们不能重写一个CityWeather,因为那样会耗时耗力，这里有现成的，实在不想写，并且获取天气的代码可能是私有的</p><p>要不把接口改了? 可是我们不止从一个天气发布源获取天气数据，改了接口，以前的其他代码就不能用了。</p><p>这就是适配器的应用场合了，</p><pre><code class="java">public class AdaptorForCityWeather extends CityWeather implements WeatherGet {    public String getTheCityWeather(String city) {        int weather_id = 0;        switch (city) {            case &quot;Beijing&quot;:                weather_id = 1;                break;            default:                    break;        }        if(weather_id!=0) {            return getWeather(weather_id);        }else {            return &quot;&quot;;        }    }}</code></pre><p>这样我们完全可以这么用了:</p><pre><code class="java">WeatherGet weatherGet = new AdaptorForCityWeather();System.out.println(weatherGet.getTheCityWeather(&quot;Beijing&quot;));</code></pre><p>方法调用起来和其他的没什么两样，完全可以放进列表中循环调用。只要实现我们用的接口，我们就不需要关注其他的差异。</p><p>如果我们比较贪心，想要一个接口实现多个接口不同的已有类的功能怎么办，可以看到我们上面用的是继承，很多语言是不支持多继承的，比如java</p><p>这样可以用关联的方式，通过生成旧类的变量来实现那么上面的接口类可以略作修改</p><pre><code class="java">public class AdaptorForCityWeather implements WeatherGet {    public String getTheCityWeather(String city) {                CityWeather cityWeather = new CityWeather();        int weather_id = 0;        switch (city) {            case &quot;Beijing&quot;:                weather_id = 1;                break;            default:                                                                          break;                                                        }        if(weather_id!=0) {                                                           return cityWeather.getWeather(weather_id);        }else {            return &quot;&quot;;                                                            }                                                                     }}</code></pre><p>用的例子是比较简单的适配器，我觉得以后遇到复杂的顺着这种思路应该能够理的清。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式，适配器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-抽象工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>走过了简单工厂模式和工厂模式，我来了解一下抽象工厂模式，现在已经知道“工厂”二字的含义了，就是帮别人建造对象，想想JDBC(数据库连接库)中用到的getConnection之类的方法，这就是工厂模式的应用啊。但是简单工厂模式和工厂模式都存在那个添加和修改必须更改以前代码的问题，这是不符合开闭原则的，也不是我们非要鸡蛋里挑骨头，而是在大体量的项目中，能不重新编译就不重新编译，能不引入更多变数就不引入更多变数，更希望的是像vscode编辑器的插件一样，这样的扩展性让人很舒服，开发者不需要修改官方的源码，每个人都可以互相不影响的开发插件。</p><p>那么如何令工厂模式符合开闭原则呢，能不能我从配置文件中动态获取类的名称然后自动的选择调用哪个工厂呢，当然可以。</p><pre><code class="java">MapFactorys myMap = Class.forName(&quot;MapAFactory&quot;).newInstance();</code></pre><p>当提供的参数变成字符串的话，我们的可操作性就变大了。其实用Ruby这样的元编程语言能把工厂模式做的更好。</p><p>接下来看一下抽象工厂模式<br>工厂模式和抽象工厂模式最大的区别就是</p><ul><li>工程模式面向单个层面的产品</li><li>抽象工厂模式面向多个层面的产品</li></ul><p>一个游戏肯定不止有地图，这个地图上得有对应的野怪，得有对应的据点吧，得有杂七杂八的其他东西，我们前面已经这么较真设计了，肯定忍受不了这么多东西都把责任扔在地图身上。<br>一个工厂可不可以在建立地图的时候，把这张图对应的各个品种的野怪和各个类型的据点(建筑物)给搞定呢。</p><p>在原来的代码的基础上添加Monster相关</p><pre><code class="java">//Monster 接口public interface Monster {    public void say();}public class MonsterA implements Monster{    public void say() {        System.out.println(&quot;I am Monster A&quot;);    }}public class MonsterB implements Monster {    public void say() {        System.out.println(&quot;I am Monster B&quot;);    }}</code></pre><p>修改一下工厂相关</p><pre><code class="java">public interface Factorys {    public static Factorys getFactory(String select){        Factorys factorys = null;        switch (select){            case &quot;FactoryA&quot;:                factorys = new FactoryA();                break;            case &quot;FactoryB&quot;:                factorys = new FactoryB();                break;            default:                factorys =null;        }        return factorys;    }    public Monster getMonster();    public GameMap getGameMap();}public class FactoryA implements Factorys {    public Monster getMonster() {        return new MonsterA();    }    public GameMap getGameMap() {        return new MapA();    }}public class FactoryB implements Factorys{    public Monster getMonster() {        return new MonsterB();    }    public GameMap getGameMap() {        return new MapB();    }}</code></pre><p>其实从这里就可以看出，抽象工厂模式并没有更优秀，只是和工厂模式适合的场合不一样，这里的FactoryA 和 FactoryB 其实是不同的生产组合。</p><p>客户端代码</p><pre><code>import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;        Monster monster = null;        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            Factorys f = Factorys.getFactory(selected);            monster = f.getMonster();            map = f.getGameMap();        }        if(map!=null &amp;&amp; monster!=null) {            map.draw();            monster.say();        }    }}</code></pre><p>如果我们添加一个新品种的怪物或者新的地图又或者新的一种组合，都可以通过添加该产品接口下的类和新的工厂类，如果配合一开始所说的Class.forname方法，可以满足开闭原则，但要是我要加入据点这一新的种类呢，亦或者说这一新的层次呢，那我所有的已有的工厂都需要新加一个方法，getXXXX，所以是不满足开闭原则的。真正体会到了设计模式只是提供一种解决问题的思路，没有什么所谓的标准定式，需要根据实际的情况选择和改变。所以真正有意义的是前人这种思考的方式。<br>看后面能不能用ruby实现一个更优美的工厂方法吧。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>上一篇遗漏了一些问题，工厂模式特别适合那种创建比较复杂的对象，这样将创建的任务交给其他部分，使得客户端代码更简介，调用更方便。后来者少写代码，减少代码的重复，提高复用性。<br>简单工厂模式比工厂模式简单，但工厂模式是简单工厂模式的进化么？我觉得不是，因为该少的东西一点都没少，那工厂模式多了什么？</p><p>工厂模式的思路大概是这样的，还用上一篇游戏地图的例子，每一个地图所需要的参数和定制有可能是不一样的，要不要为每一个地图单独适配一个自己专门的工厂呢，我们把复杂的创建逻辑放在属于这个地图的工厂里，那这样，彼此的工厂不会混乱，地图本身的类也更符合一个模型的结构。这就是工厂模式，为每一个地图创建一个单独的工厂。</p><p>那么依据面向接口编程的原则，给出地图的代码</p><pre><code class="java">//定义统一的调用接口public interface GameMap{    public void draw();}//普通地图类 A 和 Bpublic class MapA implements GameMap{    public void draw(){        System.out.println(&quot;This is MapA&quot;);            }}public class MapB implements GameMap{    public void draw(){        System.out.println(&quot;This is MapB&quot;);    }}</code></pre><p>接下来是工厂类的结构</p><pre><code class="java">//工厂的接口public interface MapFactorys {    public static MapFactorys createFactory(String selected){        MapFactorys mapFactorys = null;        switch (selected){            case &quot;MapAFactory&quot;:                mapFactorys = new MapAFactory();                break;            case &quot;MapBFactory&quot;:                mapFactorys = new MapBFactory();                break;                default:                    mapFactorys = null;        }        return mapFactorys;    }    public GameMap createMap();}//具体的工厂public class MapAFactory implements MapFactorys{    public GameMap createMap() {        return new MapA();    }}public class MapBFactory implements MapFactorys{    public GameMap createMap() {        return new MapB();    }}</code></pre><p>确实，单一工厂只生产单一产品，在这里就是只生产单一的地图。<br>客户端的逻辑基本不需要变。</p><pre><code class="java">import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            map = MapFactorys.createFactory(selected).createMap();        }        if(map!=null) map.draw();    }}</code></pre><p>这样改的好处目前是看不来的，这是因为没看到我们用工厂生产一个东西有多么复杂，试想如果构建一个东西需要很多先决条件呢，也就是必须分为几步的话，不同的地图，这几步还不一样的话，工厂模式的好处就会体现出来，成功的分离了产品和产品之间的变化点。</p><p>但是工厂模式仍然有比较大的麻烦，相信大家也发现了，在工厂接口中的静态方法，免不了还是一堆的条件判断。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式-简单工厂模式</title>
      <link href="/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>公认的有理之言已经被传递的铺天盖地，不多我一个传播者，所以我说一下自己的思考，还希望看到的人对有错存疑之言不吝赐教。</p><p>设计模式是在实践中总结出的做出更好的软件的一些方法，什么是更好的软件，就我看来是在当前基础上不管是修改还是添加，都能给开发者省点力气的软件。能做到这点就足以说明这个软件的结构很好，并且在开发的时候不仅考虑了眼下的事情，还考虑了将来的事。应用设计模式的代码不一定性能更优，不一定代码更少，这取决于代码的体量和计划中的生存周期。</p><p>我们玩游戏一般都会有各种各样的地图，我们可以灵活的在各种地图之间切换,那么一般直觉的设计是下面这样的:</p><pre><code class="java">public class Client{    //客户端类    //在这里接受用户输入    //判断输入是哪种地图，然后生成指定的地图。    /*        switch(选择)        {            case XX :          ............        }    */}</code></pre><p>相信上面的简明代码大家都能看懂，这个代码一看上去是没有问题的，不妨多想一步，我每次增加或者修改地图，都需要重新修改客户端代码，一是容易污染客户端代码，随着地图的增加，开发者对客户端代码编辑次数增加，难免会误动其他代码，或者多个人同时需要修改不同的东西，而这些东西都在客户端，同步问题，版本控制问题就会都暴露出来，由此可见，这不是客户端应该干的事，我们应该把选择地图这件事分离出来。</p><p>容易想到，我们建立一个单独的类，客户端只负责给它想要的类的名字，产生地图的细节和根据名字做出判断都交给这个类来做，那事情是不是就解决了? 客户端中获知这些类叫什么，有多少地图，这都是非代码信息，完全可以用配置文件或者用户输入来解决，也就是说我们让客户端真正分离出去了，再也不用修改客户端。代码示例如下</p><pre><code class="java">//定义统一的调用接口public interface GameMap{    public void draw();}//普通地图类 A 和 Bpublic class MapA implements GameMap{    public void draw(){        System.out.println(&quot;This is MapA&quot;);            }}public class MapB implements GameMap{    public void draw(){        System.out.println(&quot;This is MapB&quot;);    }}//负责处理地图选择的逻辑public class GameMapFactory{    private static GameMap map;    public static GameMap getMap(String selected){        switch (selected){            case &quot;MapA&quot;:                map = new MapA();                break;            case &quot;MapB&quot;:                map = new MapB();                break;            default:                map = null;                break;        }        return map;    }}import java.util.Scanner;public class Client {    public static void main(String[] args){        Scanner scan = new Scanner(System.in);        String selected = &quot;&quot;;        GameMap map = null;                //地图名可以从输入得到，但更合适的是从配置文件得到。        if(scan.hasNext()){            selected = scan.next();        }        if(!selected.isEmpty()) {            map = GameMapFactory.getMap(selected);        }        if(map!=null) map.draw();    }}</code></pre><p>这样我们每次扩展或者修改的时候只需要单独修改 GameMapFactory 的源码就可以。 然而等到地图多了，这里面的代码仍然会不太优美。所以人们又想出了工厂模式。</p><p>未完待续。。。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式,工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Archlinux 安装.net core</title>
      <link href="/2018/10/16/Archlinux-%E5%AE%89%E8%A3%85-net-core/"/>
      <url>/2018/10/16/Archlinux-%E5%AE%89%E8%A3%85-net-core/</url>
      
        <content type="html"><![CDATA[<p>从Arch源安装:</p><pre><code class="bash">sudo pacman -S dotnet-sdk</code></pre><p>这个时候已经安装了.net core<br>找一个心仪的存放工程的目录</p><pre><code class="bash">dotnet new mvc --auth Individual -o YouProjectName</code></pre><p>这里的几个参数解释一下，new 是创建新工程，类似于django，rails创建工程时的模式。<br>mvc是指建立web工程，–auth是认证方式，这里几个可选的参数，具体说明参见<a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-new?tabs=netcore21" target="_blank" rel="noopener">MSDN</a><br>一般教程讲到这就是运行工程了</p><pre><code class="bash">cd YouProjectNamedotnet run</code></pre><p>但是在我这边出了些问题，提示如下：</p><blockquote><p>System.InvalidOperationException: Unable to configure HTTPS endpoint. No server certificate was specified, and the default developer certificate could not be found.To generate a developer certificate run ‘dotnet dev-certs https’. To trust the certificate (Windows and macOS only) run ‘dotnet dev-certs https –trust’. For more information on configuring HTTPS see <a href="https://go.microsoft.com/fwlink/?linkid=848054" target="_blank" rel="noopener">https://go.microsoft.com/fwlink/?linkid=848054</a>.</p></blockquote><p>解决方案如下：</p><pre><code class="bash">dotnet tool install --global dotnet-dev-certs</code></pre><p>然后执行</p><pre><code class="bash">dotnet dev-certs https</code></pre><p>如果提示错误：</p><blockquote><p>A fatal error occurred, the required library libhostfxr.so</p></blockquote><p>接下来设置环境变量</p><pre><code class="bash">export DOTNET_ROOT=/opt/dotnet</code></pre><p>重新执行出错的那句。</p><p>可以把设置环境变量的语句放入<br>~/.bashrc 或者 ~/.xprofile文件，这样就不需要每次手动加载了。</p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Archlinux,dotnet core </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Archlinux安装Boost库</title>
      <link href="/2018/10/16/Archlinux%E5%AE%89%E8%A3%85Boost/"/>
      <url>/2018/10/16/Archlinux%E5%AE%89%E8%A3%85Boost/</url>
      
        <content type="html"><![CDATA[<p>Archlinux 软件源中有boost 不需要自己编译安装。</p><pre><code class="bash">sudo pacman -S boost</code></pre><p>刷新一下当前环境</p><pre><code>ldconfig</code></pre><p>新建立一个代码文件，测试一下boost库是否安装成功了。</p><pre><code class="cpp">#include &lt;boost/timer.hpp&gt; //boost库统一用hpp#include &lt;iostream&gt;using namespace boost;using namespace std;int main(){    timer t;    cout &lt;&lt; &quot;max timespan:&quot; &lt;&lt; t.elapsed_max() / 3600 &lt;&lt; &quot;h&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;min timespan:&quot; &lt;&lt; t.elapsed_min() &lt;&lt; &quot;s&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;now time elapsed:&quot; &lt;&lt; t.elapsed() &lt;&lt; &quot;s&quot; &lt;&lt; endl;}</code></pre><p>编译的时候按照gnu的编译规矩要手动指定库文件</p><pre><code class="bash">g++ source_filename.cpp -lboost_timer -o execute_filename</code></pre><p>这里用-lboost_timer是因为我们用到了timer头文件。用其他库要改成-lboost_xxx</p>]]></content>
      
      
      <categories>
          
          <category> Boost </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boost,Archlinux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识 Vue.js 时的心理活动</title>
      <link href="/2018/10/03/%E5%88%9D%E8%AF%86-Vue-js-%E6%97%B6%E7%9A%84%E5%BF%83%E7%90%86%E6%B4%BB%E5%8A%A8/"/>
      <url>/2018/10/03/%E5%88%9D%E8%AF%86-Vue-js-%E6%97%B6%E7%9A%84%E5%BF%83%E7%90%86%E6%B4%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<p>在大学参与的小项目或者作业中总是当那个写后端的角色，前后林林总总用了各式框架和各种语言，包括java, python-flask, ruby on rails,总觉得视觉设计很炫酷，视觉的美感比较直接和强烈，也更容易被人共鸣。你想一个普通人看到你写的代码是不可能说：哇，这真是太美了。这点真的很难，很多写代码很多年的人也不会有这种美感。所以说这么多，总而言之，我想学一些前端，不是为了工作，而是为了自己在自娱自乐的时候用更多发挥的空间。</p><p>以前也看过javascript,html,css的相关知识，但你要说实战的时候能信手拈来还差的远。但这个东西吧，思想上很难接触，html，css是纯标记的语言，让人感觉死板和本身的工具性特别浓厚。排版啊，样式啊，是这些东西，而不是传统后端的逻辑。我不太想学javascript，可能是我从它的形式里很难找到美感吧，个人感受。</p><p>在合作完成作业的时候，做前端的同学用到了vue.js，我虽然早有耳闻，但没有这种亲身接触的印象深刻。首先，我觉得这个框架设计的很清晰，解决了很多人们不需要关心的问题。于是我去<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vue官网</a>看完了大半的文档。但是，却难以有整体的把握，后来在youtube上看了个60分钟介绍的短片，又自己做了一个toy project，这才感觉可以上手了。</p><p>那么说一下当下的理解。</p><p>关于v-if v-for之类的在理解上没有什么问题。关键是模板模块和路由。vue为了提高代码的重复利用，允许用户把代码分成一个个模块，那么在构建一个新的网页的时候如果有需要的组件可以直接拿过来用。一个网站的不同网页为了保持样式的统一肯定有很多部分需要在不同的网页中重复利用，这样可以直接在父元素中包含这个组件。组件之间允许嵌套。组件之间可以通过props传递变量。每一个组件就是一个小的页面，在这个组件的vue文件中可以直接定义自己js和css。使得整个工程的结构清晰。一张网页就可以看成一张画纸，组件就是拼图，就看怎么摆放了。<br><br><br><img src="http://pbn2nc8d5.bkt.clouddn.com/github/blog/10-03-1.jpgtimg%20%281%29.jpeg" alt=""><br><br><br>做的一个样例，列表内容临时去<a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a>摘的，应该看不清吧。</p><p><img src="http://pbn2nc8d5.bkt.clouddn.com/vu1.png" alt=""></p><pre><code class="language-javascript line-numbers">&lt;template&gt;    &lt;div class="HomePage"&gt;        &lt;div class="person"&gt;            &lt;img class="headico" v-bind:src="user.headico"&gt;            &lt;h3 class="username"&gt;{{user.username}}&lt;/h3&gt;            &lt;p&gt;{{user.info}}&lt;/p&gt;        &lt;/div&gt;        &lt;articlelistitem&gt;&lt;/articlelistitem&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ArticleListItem from './ArticleListItem.vue'export default {  name: 'HomePage',  data () {    return {      user: {        headico: 'http://img4.duitang.com/uploads/item/201411/09/20141109142633_ncKBY.thumb.700_0.jpeg',        username: 'Xblame',        info: '一个简单的读书人'      }    }  },  components: {    'articlelistitem': ArticleListItem  }}&lt;/script&gt;&lt;style scoped&gt;.headico {    width: 100px;    height: 100px;    border-radius: 50px;}&lt;/style&gt;</code></pre><p>这其实是一个HomePage的组件，就是图上的用户头像，姓名，信息那一块。下面的列表是一个单独的模块ArticleListItem，HomePage中引用了它。</p><p>一个网站的路由是比较核心的功能，路由就是通向一个网页的链接，比如对于一个母版的网页，中间包含了一个组件，那么针对不同的链接可以通过路由更换其中的组件，首先vue有一个总的路由，这个路由可以通向各个大的组件，但一个复杂的网页中，大的组件势必包含一些小的组件，这个时候需要嵌套路由。举个例子：</p><p><strong>访问一个网站的域名，也就是访问其根目录，首先route根据你定义的根目录渲染那个模块，如果这个模块还包含一个&lt;router-view/&gt;的路由入口,比如你想让ArticleListItem插入在这，你就需要访问/articlelistitem,即在父组件的路由路径后加上自己的路由路径。</strong></p><p>不建议嵌套很多层，根据在其他领域得到的经验。层次结构超过一定限度会极大增加复杂度，尽可能转化成平面结构。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MRB主引导记录</title>
      <link href="/2018/09/25/MRB%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/09/25/MRB%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>这几天因为一直在看操作系统和文件系统相关的书，了解到了MBR的作用的结构，记录一下。<br>MBR(master boot record)主引导记录位于存储设备的绝对零扇区，这里的绝对零扇区是指物理上的起点。MBR整个结构共占用<strong>512</strong>Byte。接下来用一个C语言结构体来表示一下</p><pre><code class="language-c line-numbers">struct MBR{    uint8 PartCode[446];    //MBR引导程序    struct Partition DPT[4];    //四个分区信息    uint8 BootSectSig0;     //55    uint8 BootSectSig1;     //AA};/* 55 AA 在最后两个字节，小端字序，真实值为AA55,代表正常扇区结束。*/struct Partition{    uint8 Active;   //引导指示符，指明次分区是否是活动分区，取值为0x80，说明可以引导操作系统，通常取0    uint8 StartHead;    //分区的开始扇头    uint16 StartCylSect;    //开始柱面和扇区，前6位为开始扇区，后10位为开始柱面    uint8 PartType;     //分区类型    uint8 EndHead;  //分区的结束头    uint16 EndCylSect;  //结束柱面与扇区，前6位为结束扇区，后10位为结束柱面    uint32 StartLBA;    //分区的第一个扇区地址    uint32 TotalSector; //分区的总扇区数};</code></pre><blockquote><br>  该处出自 《嵌入式FAT32文件系统设计与实现》于振南 编著<br></blockquote><p>DPT(Disk Partition Table ) 磁盘分区表</p><p>开始的446个字节的是一段引导代码。简单来说是一段 程序，在计算机上电以后，<a href="https://baike.baidu.com/item/bios" target="_blank" rel="noopener">BIOS</a>(Base Input Output System 基本输入输出系统)会自动读取MBR的前446个字节，然后执行这段代码，这段代码会对mbr区后面的分区信息的代码进行读取分析，找到分区信息，根据分区信息找到需要引导的操作系统的程序，进而启动操作系统。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Archlinux 声音配置</title>
      <link href="/2018/09/13/Archlinux-%E5%A3%B0%E9%9F%B3%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/09/13/Archlinux-%E5%A3%B0%E9%9F%B3%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>Archlinux 通常使用alsa管理声音，需要安装alsa-utils包<br>安装完是默认静音的。需要执行</p><pre><code class="language-shell line-numbers">amixer sset Master unmute</code></pre><p>如果提示：amixer: Unable to find simple control ‘Master’,0<br>则表示不能找到声卡设备需要继续配置<br>执行命令获取声卡的声卡ID和设备ID</p><pre><code class="language-shell line-numbers">aplay -l</code></pre><p>结果如下</p><pre><code class="language-shell line-numbers">**** List of PLAYBACK Hardware Devices ****card 0: HDMI [HDA Intel HDMI], device 3: HDMI 0 [HDMI 0]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 7: HDMI 1 [HDMI 1]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 8: HDMI 2 [HDMI 2]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 9: HDMI 3 [HDMI 3]  Subdevices: 1/1  Subdevice #0: subdevice #0card 0: HDMI [HDA Intel HDMI], device 10: HDMI 4 [HDMI 4]  Subdevices: 1/1  Subdevice #0: subdevice #0card 1: PCH [HDA Intel PCH], device 0: ALC282 Analog [ALC282 Analog]  Subdevices: 0/1  Subdevice #0: subdevice #0</code></pre><p>把下列配置添加到系统级别的 /etc/asound.conf 或用户级别的 ~/.asoundrc 文件。如果文件不存在，可以手动创建。其中的各个ID，根据实际情况调整：</p><pre><code class="language-shell line-numbers">defaults.pcm.card 1   #根据上面输出的信息，ALC282是我的设备，选择card=1defaults.pcm.device 0 #device 为0defaults.ctl.card 1  #决定哪个声卡能由alsamixer控制</code></pre><p>同时，对于i3wm,fluxbox之类的wm（窗口管理器），而不是DE(Desktop environment),往往需要自己设置音量快捷键<br>这里给出i3的例子（编辑~/.config/i3/config）文件</p><pre><code class="language-shell line-numbers">#设置静音bindsym XF86AudioMute exec "amixer -q sset Master,0 toggle"#设置音量调节bindsym XF86AudioRaiseVolume exec --no-startup-id  amixer -c 0 set Master 3%+bindsym XF86AudioLowerVolume exec --no-startup-id  amixer -c 0 set Master 3%-</code></pre>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alsamixer,Archlinux,声音 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>grub 提示: Failed to connect to lvmetad……</title>
      <link href="/2018/09/13/grub-%E6%8F%90%E7%A4%BA-Failed-to-connect-to-lvmetad%E2%80%A6%E2%80%A6/"/>
      <url>/2018/09/13/grub-%E6%8F%90%E7%A4%BA-Failed-to-connect-to-lvmetad%E2%80%A6%E2%80%A6/</url>
      
        <content type="html"><![CDATA[<p>编辑 /etc/lvm/lvm.conf<br>找到 use_lvmetad = 1<br>将其修改为</p><pre><code class="language-bash line-numbers">use_lvmetad = 0</code></pre>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grub </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rails-理解</title>
      <link href="/2018/09/11/Rails-%E7%90%86%E8%A7%A3/"/>
      <url>/2018/09/11/Rails-%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Rail 核心目录在于app下面的model,controller,view<br><br><br>是经典的MVC结构，以Model数据为中心，Model通过ActiveRecord模块与数据库连接，不需要自己在Model里定义变量和getter，setter之类的在java中常写的存取函数，只需要在db/migrate目录中定义同名数据库表，接下来便开始忽略与数据库相关的事，暂时将其透明化。controller负责定义一系列与数据相关的动作，组织数据，生成视图。即负责链接数据和视图。<br><br><br>route.rb 负责链接url和controller</p><p><img src="http://pbn2nc8d5.bkt.clouddn.com/github/blog/10-03-3.jpgrails%E7%90%86%E8%A7%A3.png" alt=""></p><p>view 中指定的视图应当与其在controller中对应的动作存在共享实例变量和几个全局变量，进行数据的交互。</p><p>controller 和 view 的对应关系，model和数据库的对应关系使用约定。一开始觉得体系庞大，难以掌控，我觉得不妨先观察，然后思考，不知所以然的照着教程写一遍不利用后面摆脱固定的模式限制进行自定义。不妨多些勇敢，多尝试，不用觉得与示范做法不一样，这样才能真正的使用。</p>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rails </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python 类中方法参数 self</title>
      <link href="/2018/09/06/python-%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-self/"/>
      <url>/2018/09/06/python-%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0-self/</url>
      
        <content type="html"><![CDATA[<h3>内存</h3><p>Python 类在内存中的实现是类有自己的一个空间，存放类中的定义的变量和方法，在声明一个实例的时候，为该实例分配一块新的空间，但仍有引用指向类，这也是大部分面向对象的设计方法，对大家都有的东西只存在一份。当实例变量中的变量绑定新的值，或是方法覆写这些自己独有的东西存放在自己的空间里。当多个实例变量去访问同一个函数，这个函数如果没有被覆写应当是在类空间里的。那这个方法自然而然就需要区分是哪个实例调用的自己。在这里，python为了精确，需要手动声明这个需要传递的实例的引用。</p><h3>为什么是self?</h3><p>self其实是一种约定俗称的写法，因为传递实例变量引用的这个过程是自动的，python会自动把引用填入第一个参数，所以，python类的实例方法至少接受一个参数。python只接受第一个参数，而不管这个参数的名字，所以可用任何一个单词替换self，但self意义比较明显，所以大家习惯用self。</p><blockquote><br>  Often, the first argument of a method is called self. This is nothing more than a convention: the name self has absolutely no special meaning to Python. Note, however, that by not following the convention your code may be less readable to other Python programmers, and it is also conceivable that a class browser program might be written that relies upon such a convention<br>  —-Python Document<br></blockquote>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> class,python,self </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Rails 多对多 自联结 建立好友关系表</title>
      <link href="/2018/09/03/Rails-%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E8%87%AA%E8%81%94%E7%BB%93-%E5%BB%BA%E7%AB%8B%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E8%A1%A8-md/"/>
      <url>/2018/09/03/Rails-%E5%A4%9A%E5%AF%B9%E5%A4%9A-%E8%87%AA%E8%81%94%E7%BB%93-%E5%BB%BA%E7%AB%8B%E5%A5%BD%E5%8F%8B%E5%85%B3%E7%B3%BB%E8%A1%A8-md/</url>
      
        <content type="html"><![CDATA[<h3>Model</h3><pre><code class="language-Ruby ">class User &lt; ApplicationRecordhas_many :a_friends, class_name: "Friendship",foreign_key: :request_friend_idhas_many :r_friends, class_name: "Friendship",foreign_key: :answer_friend_idhas_many :answer_friends , class_name:"User" ,through: :a_friendshas_many :request_friends,class_name: "User" ,through: :r_friendsend</code></pre><h3>联结表</h3><pre><code class="language-Ruby ">class Friendship &lt; ApplicationRecordbelongs_to :request_friend,class_name: "User"belongs_to :answer_friend,class_name: "User"end</code></pre><h3>迁移</h3><pre><code class="language-Ruby ">class CreateFriendships &lt; ActiveRecord::Migration[5.2]def changecreate_table :friendships do |t|t.integer :request_friend_idt.integer :answer_friend_idt.timestampsendendend</code></pre>]]></content>
      
      
      <categories>
          
          <category> 代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rails,多对多,自联结,好友关系 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
  
</search>
